/*******************************************************************************
 * This file is part of the Incubed project.
 * Sources: https://github.com/slockit/in3-c
 *
 * Copyright (C) 2018-2022 slock.it GmbH, Blockchains LLC
 *
 *
 * COMMERCIAL LICENSE USAGE
 *
 * Licensees holding a valid commercial license may use this file in accordance
 * with the commercial license agreement provided with the Software or, alternatively,
 * in accordance with the terms contained in a written agreement between you and
 * slock.it GmbH/Blockchains LLC. For licensing terms and conditions or further
 * information please contact slock.it at in3@slock.it.
 *
 * Alternatively, this file may be used under the AGPL license as follows:
 *
 * AGPL LICENSE USAGE
 *
 * This program is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * [Permissions of this strong copyleft license are conditioned on making available
 * complete source code of licensed works and modifications, which include larger
 * works using a licensed work, under the same license. Copyright and license notices
 * must be preserved. Contributors provide an express grant of patent rights.]
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see <https://www.gnu.org/licenses/>.
 *******************************************************************************/

// ::: This is a autogenerated file. Do not edit it manually! :::
// clang-format off

#include "../../core/client/request_internal.h"

// list of availbale rpc-functions
#ifndef __RPC_SIGNERS_H
#define __RPC_SIGNERS_H

/**
 * Generates 32 random bytes.
 * If /dev/urandom is available it will be used and should generate a secure random number.
 * If not the number should not be considered sceure or used in production.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t seed : (bytes) the seed. If given the result will be deterministic.
 * Returns:
 *   - bytes_t : (bytes32) the 32byte random data
 */
static inline in3_ret_t rpc_call_in3_createKey(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, bytes_t seed) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\"", (bytes_t) seed);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "in3_createKey", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_IN3_CREATEKEY "in3_createKey"

/**
 * Generates 32 byte private key based on BIP 32.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t seed  : (bytes) the seed. it mus be at least 16 bytes long
 *   - char*   curve : (string) the name of the curve. should be one of `secp256k1`,`secp256k1-decred`,`secp256k1-groestl`,`secp256k1-smart`,`nist256p1`,`ed25519`,`ed25519 cardano seed`,`ed25519-sha3`,`curve25519`,`ed25519-keccak`
 *   - char*   path  : (string) the derivation path as specified in BIP32
 * Returns:
 *   - bytes_t : (bytes32) theprivate key
 */
static inline in3_ret_t rpc_call_in3_bip32(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, bytes_t seed, char* curve, char* path) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\",\"%S\",\"%S\"", (bytes_t) seed, (char*) curve, (char*) path);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "in3_bip32", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_IN3_BIP32 "in3_bip32"

/**
 * generates a mnemonic based on bip39 ( https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki )
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t  seed  : (bytes) the seed. if a seed is passed, this seed will be used to generate it, making it deterministic.
 *   - uint32_t words : (uint32) the number of words. it must one of 12, 15, 18, 21 or 24 (default). This number will also have an effect on the entropy or security.
 * Returns:
 *   - char* : (string) a list of words based on bip39
 */
static inline in3_ret_t rpc_call_in3_bip39_create(in3_rpc_handle_ctx_t* ctx, char** _res, bytes_t seed, uint32_t words) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\",\"%u\"", (bytes_t) seed, (uint32_t) words);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "in3_bip39_create", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_string(res);
  return r;
}
#define FN_IN3_BIP39_CREATE "in3_bip39_create"

/**
 * decodes a mnemonic and returns the seed as 64 bytes.
 *
 *
 *
 * Parameters:
 *
 *   - char* mnemonic   : (string) the mnemonic
 *   - char* passphrase : (string) the passphrase
 * Returns:
 *   - bytes_t : (bytes) the resulting seed
 */
static inline in3_ret_t rpc_call_in3_bip39_decode(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, char* mnemonic, char* passphrase) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%S\",\"%S\"", (char*) mnemonic, (char*) passphrase);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "in3_bip39_decode", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_IN3_BIP39_DECODE "in3_bip39_decode"

/**
 * Generates the public key from a private key for ed25519.
 *
 *
 * Parameters:
 *
 *   - bytes_t pk : (bytes32) the private key
 * Returns:
 *   - bytes_t : (bytes32) the 32byte public key
 */
static inline in3_ret_t rpc_call_in3_ed25519_pk2pub(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, bytes_t pk) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\"", (bytes_t) pk);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "in3_ed25519_pk2pub", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_IN3_ED25519_PK2PUB "in3_ed25519_pk2pub"

/**
 * signs the message with for ed25519.
 *
 *
 * Parameters:
 *
 *   - bytes_t message : (bytes) the message to sign
 *   - bytes_t pk      : (bytes32) the private key
 * Returns:
 *   - bytes_t : (bytes) the 64byte signature
 */
static inline in3_ret_t rpc_call_in3_ed25519_sign(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, bytes_t message, bytes_t pk) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\",\"%B\"", (bytes_t) message, (bytes_t) pk);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "in3_ed25519_sign", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_IN3_ED25519_SIGN "in3_ed25519_sign"

/**
 * verifies the signature based on ed25519.
 *
 *
 * Parameters:
 *
 *   - bytes_t message   : (bytes) the message which was signed
 *   - bytes_t signature : (bytes) the 64 byte signature
 *   - bytes_t pubkey    : (bytes32) the 32 byte public key, whic is expected
 * Returns:
 *   - bool : (bool) true, if could be successfully verified.
 */
static inline in3_ret_t rpc_call_in3_ed25519_verify(in3_rpc_handle_ctx_t* ctx, bool* _res, bytes_t message, bytes_t signature, bytes_t pubkey) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\"", (bytes_t) message, (bytes_t) signature, (bytes_t) pubkey);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "in3_ed25519_verify", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_int(res);
  return r;
}
#define FN_IN3_ED25519_VERIFY "in3_ed25519_verify"

/**
 * converts cyrptographic data based on the curve and type into a different form.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t data : (bytes) the data to convert. The length and kind of data depends on the conversion type.
 *   - char*   type : (string) the conversion type.
 *                    This Type may be prefixed with curvetype to be used (`ecdsa_` or `eddsa_`) , like `eddsa_pub32`.
 *
 *                    The following types are supported:
 *                    - pub64 : converts a private key (32 bytes) to a public key (64 bytes)
 *                    - pub32 : converts a private key (32 bytes) to a public key (32 bytes)
 *                    - sig_der : converts a signature (65 bytes) to a DER-encoded signature
 *                    - sig_from_der : converts a  DER-encoded signature to a signature (65 bytes)
 *                    - pub_der : converts a public key (32 or 64 bytes) to a DER-encoded pubkey
 *
 * Returns:
 *   - bytes_t : (bytes) the converted bytes.
 */
static inline in3_ret_t rpc_call_in3_crypto_convert(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, bytes_t data, char* type) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\",\"%S\"", (bytes_t) data, (char*) type);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "in3_crypto_convert", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_IN3_CRYPTO_CONVERT "in3_crypto_convert"

/**
 * extracts the address from a private key.
 *
 *
 * Parameters:
 *
 *   - bytes_t pk : (bytes32) the 32 bytes private key as hex.
 * Returns:
 *   - bytes_t : (bytes) the address
 */
static inline in3_ret_t rpc_call_in3_pk2address(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, bytes_t pk) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\"", (bytes_t) pk);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "in3_pk2address", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_IN3_PK2ADDRESS "in3_pk2address"

/**
 * extracts the public key from a private key.
 *
 *
 * Parameters:
 *
 *   - bytes_t pk : (bytes32) the 32 bytes private key as hex.
 * Returns:
 *   - bytes_t : (bytes) the public key as 64 bytes
 */
static inline in3_ret_t rpc_call_in3_pk2public(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, bytes_t pk) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\"", (bytes_t) pk);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "in3_pk2public", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_IN3_PK2PUBLIC "in3_pk2public"

/**
 * extracts the public key and address from signature.
 *
 *
 * Parameters:
 *
 *   - char*   msg     : (string) the message the signature is based on.
 *   - bytes_t sig     : (bytes) the 65 bytes signature as hex.
 *   - char*   sigtype : (string) the type of the signature data : `eth_sign` (use the prefix and hash it), `raw` (hash the raw data), `hash` (use the already hashed data). Default: `raw`
 * Returns:
 *   - d_token_t* : ([object Object]) the extracted public key and address
 */
static inline in3_ret_t rpc_call_in3_ecrecover(in3_rpc_handle_ctx_t* ctx, d_token_t** res, char* msg, bytes_t sig, char* sigtype) {
  char*     jpayload = sprintx("\"%S\",\"%B\",\"%S\"", (char*) msg, (bytes_t) sig, (char*) sigtype);
  in3_ret_t r        = req_send_sub_request(ctx->req, "in3_ecrecover", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_IN3_ECRECOVER "in3_ecrecover"

/**
 * prepares a Transaction by filling the unspecified values and returens the unsigned raw Transaction.
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx : (eth_transaction) the tx-object, which is the same as specified in [eth_sendTransaction](https://eth.wiki/json-rpc/API#eth_sendTransaction).
 * Returns:
 *   - bytes_t : (bytes) the unsigned raw transaction as hex.
 */
static inline in3_ret_t rpc_call_in3_prepareTx(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, d_token_t* tx) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("%j", (d_token_t*) tx);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "in3_prepareTx", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_IN3_PREPARETX "in3_prepareTx"

/**
 * signs the given raw Tx (as prepared by in3_prepareTx ). The resulting data can be used in `eth_sendRawTransaction` to publish and broadcast the transaction.
 *
 *
 * Parameters:
 *
 *   - char*    tx   : (string) the raw unsigned transactiondata
 *   - uint8_t* from : (address) the account to sign
 * Returns:
 *   - bytes_t : (bytes) the raw transaction with signature.
 */
static inline in3_ret_t rpc_call_in3_signTx(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, char* tx, uint8_t* from) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%S\",\"%B\"", (char*) tx, bytes(from, 20));
  in3_ret_t  r        = req_send_sub_request(ctx->req, "in3_signTx", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_IN3_SIGNTX "in3_signTx"

/**
 * signs the given data.
 *
 *
 * Parameters:
 *
 *   - char*   msg     : (string) the message to sign.
 *   - bytes_t account : (bytes) the account to sign if the account is a bytes32 it will be used as private key
 *   - char*   msgType : (string) the type of the signature data : `eth_sign` (use the prefix and hash it), `raw` (hash the raw data), `hash` (use the already hashed data)
 * Returns:
 *   - d_token_t* : ([object Object]) the signature
 */
static inline in3_ret_t rpc_call_in3_signData(in3_rpc_handle_ctx_t* ctx, d_token_t** res, char* msg, bytes_t account, char* msgType) {
  char*     jpayload = sprintx("\"%S\",\"%B\",\"%S\"", (char*) msg, (bytes_t) account, (char*) msgType);
  in3_ret_t r        = req_send_sub_request(ctx->req, "in3_signData", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_IN3_SIGNDATA "in3_signData"

/**
 * decrypts a JSON Keystore file as defined in the [Web3 Secret Storage Definition](https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition). The result is the raw private key.
 *
 *
 * Parameters:
 *
 *   - d_token_t* key        : (keyparams) the keyparams
 *   - char*      passphrase : (string) the password to decrypt it.
 * Returns:
 *   - bytes_t : (bytes32) a raw private key (32 bytes)
 */
static inline in3_ret_t rpc_call_in3_decryptKey(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, d_token_t* key, char* passphrase) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("%j,\"%S\"", (d_token_t*) key, (char*) passphrase);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "in3_decryptKey", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_IN3_DECRYPTKEY "in3_decryptKey"

/**
 * The sign method calculates an Ethereum specific signature with:
 *
 * ```js
 * sign(keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))).
 * ```
 *
 * By adding a prefix to the message makes the calculated signature recognisable as an Ethereum specific signature. This prevents misuse where a malicious DApp can sign arbitrary data (e.g. transaction) and use the signature to impersonate the victim.
 *
 * For the address to sign a signer must be registered.
 *
 *
 *
 * Parameters:
 *
 *   - uint8_t* account : (address) the account to sign with
 *   - bytes_t  message : (bytes) the message to sign
 * Returns:
 *   - bytes_t : (bytes) the signature (65 bytes) for the given message.
 */
static inline in3_ret_t rpc_call_eth_sign(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, uint8_t* account, bytes_t message) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\",\"%B\"", bytes(account, 20), (bytes_t) message);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "eth_sign", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_ETH_SIGN "eth_sign"

/**
 * Signs a transaction that can be submitted to the network at a later time using with eth_sendRawTransaction.
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx : (eth_transaction) transaction to sign
 * Returns:
 *   - bytes_t : (bytes) the raw signed transaction
 */
static inline in3_ret_t rpc_call_eth_signTransaction(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, d_token_t* tx) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("%j", (d_token_t*) tx);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "eth_signTransaction", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_ETH_SIGNTRANSACTION "eth_signTransaction"

/**
 * returns the internal transactions send during execution of the tx. Currently this only works with geth with activated `debug` module (supporting `debug_traceTransaction` ). Also when running a pruned node, the state of transaction is only available for limited time ( mostly 5 min)
 *
 *
 * Parameters:
 *
 *   - bytes_t tx_hash : (bytes32) the transactionhash
 * Returns:
 *   - d_token_t* : (eth_internal_tx) an array of internal transactions
 */
static inline in3_ret_t rpc_call_in3_get_internal_tx(in3_rpc_handle_ctx_t* ctx, d_token_t** res, bytes_t tx_hash) {
  char*     jpayload = sprintx("\"%B\"", (bytes_t) tx_hash);
  in3_ret_t r        = req_send_sub_request(ctx->req, "in3_get_internal_tx", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_IN3_GET_INTERNAL_TX "in3_get_internal_tx"

/**
 * verifies a signature of a wallet. It will also automaticly detect a EIP-1271-Signature and verifies a multisig or other contracts.
 *
 *
 * Parameters:
 *
 *   - char*    msg         : (string) the message the signature is based on.
 *   - uint8_t* account     : (address) the account claiming to be the signer ( can be a multisig or external owned account )
 *   - bytes_t  sig         : (bytes) the Signature
 *   - char*    sigtype     : (string) the type of the signature data : `eth_sign` (use the prefix and hash it), `raw` (hash the raw data), `hash` (use the already hashed data). Default: `raw`
 *   - uint64_t blockNumber : (uint64) the blockNumber which should be used in case of an EIP-1271 Contract Signature. You need to make sure, that the configured RPC-Endpoint is running as archive node to verify against older blocks!
 * Returns:
 *   - d_token_t* : ([object Object]) the extracted public key and address
 */
static inline in3_ret_t rpc_call_in3_verifySignature(in3_rpc_handle_ctx_t* ctx, d_token_t** res, char* msg, uint8_t* account, bytes_t sig, char* sigtype, uint64_t blockNumber) {
  char*     jpayload = sprintx("\"%S\",\"%B\",\"%B\",\"%S\",\"%U\"", (char*) msg, bytes(account, 20), (bytes_t) sig, (char*) sigtype, (uint64_t) blockNumber);
  in3_ret_t r        = req_send_sub_request(ctx->req, "in3_verifySignature", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_IN3_VERIFYSIGNATURE "in3_verifySignature"

/**
 * adds a raw private key as signer, which allows signing transactions.
 *
 *
 * Parameters:
 *
 *   - bytes_t pk    : (bytes32) the 32byte long private key as hex string.
 *   - char*   curve : (string) the curve of the key.
 * Returns:
 *   - bytes_t : (bytes) the unique identifier for the sdk of given key.
 */
static inline in3_ret_t rpc_call_in3_addRawKey(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, bytes_t pk, char* curve) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\",\"%S\"", (bytes_t) pk, (char*) curve);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "in3_addRawKey", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_IN3_ADDRAWKEY "in3_addRawKey"

/**
 * decrypts a JSON Keystore file as defined in the [Web3 Secret Storage Definition](https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition) and adds it as signer.
 *
 *
 * Parameters:
 *
 *   - d_token_t* key        : (keyparams) the keyparams
 *   - char*      passphrase : (string) the password to decrypt it.
 * Returns:
 *   - uint8_t* : (address) the added address
 */
static inline in3_ret_t rpc_call_in3_addJsonKey(in3_rpc_handle_ctx_t* ctx, uint8_t** _res, d_token_t* key, char* passphrase) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("%j,\"%S\"", (d_token_t*) key, (char*) passphrase);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "in3_addJsonKey", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res).data;
  return r;
}
#define FN_IN3_ADDJSONKEY "in3_addJsonKey"

/**
 * adds a signer from a mnemomic phrase
 *
 *
 * Parameters:
 *
 *   - char*      mnemomic   : (string) the mnemomic phrase
 *   - char*      passphrase : (string) the password to decrypt it or null.
 *   - d_token_t* derivation : (string) the BIP32 derivation-path
 *   - char*      curve      : (string) the name of the curve. should be one of `secp256k1`,`secp256k1-decred`,`secp256k1-groestl`,`secp256k1-smart`,`nist256p1`,`ed25519`,`ed25519 cardano seed`,`ed25519-sha3`,`curve25519`,`ed25519-keccak`
 * Returns:
 *   - d_token_t* : (address) the added address
 */
static inline in3_ret_t rpc_call_in3_addMnemonic(in3_rpc_handle_ctx_t* ctx, d_token_t** res, char* mnemomic, char* passphrase, d_token_t* derivation, char* curve) {
  char*     jpayload = sprintx("\"%S\",\"%S\",%j,\"%S\"", (char*) mnemomic, (char*) passphrase, (d_token_t*) derivation, (char*) curve);
  in3_ret_t r        = req_send_sub_request(ctx->req, "in3_addMnemonic", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_IN3_ADDMNEMONIC "in3_addMnemonic"

/**
 * returns a array of signer_ids the client is able to sign with.
 *
 * In order to add keys, you can use [in3_addRawKey](#in3-addrawkey) or configure them in the config. The result also contains the signer_ids of any signer signer-supporting the `PLGN_ACT_SIGN_ACCOUNT` action.
 *
 *
 * Returns:
 *   - d_token_t* : (address) the array of signer_ids of all registered signers.
 */
static inline in3_ret_t rpc_call_signer_ids(in3_rpc_handle_ctx_t* ctx, d_token_t** res) {
  in3_ret_t r = req_send_sub_request(ctx->req, "signer_ids", "", NULL, res, NULL);
  return r;
}
#define FN_SIGNER_IDS "signer_ids"

/**
 * alias to signer_ids
 *
 *
 * Returns:
 *   - d_token_t* : (address) the array of signer_ids of all registered signers.
 */
static inline in3_ret_t rpc_call_eth_accounts(in3_rpc_handle_ctx_t* ctx, d_token_t** res) {
  in3_ret_t r = req_send_sub_request(ctx->req, "eth_accounts", "", NULL, res, NULL);
  return r;
}
#define FN_ETH_ACCOUNTS "eth_accounts"

#endif