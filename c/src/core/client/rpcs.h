/*******************************************************************************
 * This file is part of the Incubed project.
 * Sources: https://github.com/slockit/in3-c
 *
 * Copyright (C) 2018-2022 slock.it GmbH, Blockchains LLC
 *
 *
 * COMMERCIAL LICENSE USAGE
 *
 * Licensees holding a valid commercial license may use this file in accordance
 * with the commercial license agreement provided with the Software or, alternatively,
 * in accordance with the terms contained in a written agreement between you and
 * slock.it GmbH/Blockchains LLC. For licensing terms and conditions or further
 * information please contact slock.it at in3@slock.it.
 *
 * Alternatively, this file may be used under the AGPL license as follows:
 *
 * AGPL LICENSE USAGE
 *
 * This program is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * [Permissions of this strong copyleft license are conditioned on making available
 * complete source code of licensed works and modifications, which include larger
 * works using a licensed work, under the same license. Copyright and license notices
 * must be preserved. Contributors provide an express grant of patent rights.]
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see <https://www.gnu.org/licenses/>.
 *******************************************************************************/

// ::: This is a autogenerated file. Do not edit it manually! :::

// list of availbale rpc-functions
// @PUBLIC_HEADER
#ifndef __RPCS_H
#define __RPCS_H

/**
 * Returns data of block header for given block hash. The returned level of details depends on the argument verbosity.
 *
 *
 * Parameters:
 *
 *   - bytes_t hash      : (bytes32) The block hash
 *   - bool    verbosity : (bool) 0 or false for the hex-encoded data, 1 or true for a json object
 * Returns:
 *   - d_token_t* : (btcblockheader) the blockheader.
 *         - verbose `0` or `false`: a hex string with 80 bytes representing the blockheader
 *         - verbose `1` or `true`: an object representing the blockheader.
 */
#define TRY_CALL_GETBLOCKHEADER(ctx, res, hash, verbosity)                                               \
  {                                                                                                      \
    char*      jpayload = sprintx("\"%B\",%i", (bytes_t) hash, (int) verbosity);                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_GETBLOCKHEADER, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
  }
#define FN_GETBLOCKHEADER "getblockheader"

/**
 * Returns data of block for given block hash. The returned level of details depends on the argument verbosity.
 *
 *
 * Parameters:
 *
 *   - bytes_t hash      : (bytes32) The block hash
 *   - bytes_t verbosity : (int) 0 or false for hex-encoded data, 1 or true for a json object, and 2 for json object **with** transaction data
 * Returns:
 *   - d_token_t* : (btcblockWithTx) the block.
 *         - verbose `0` or `false`: a hex string with 80 bytes representing the blockheader
 *         - verbose `1` or `true`: an object representing the blockheader.
 */
#define TRY_CALL_GETBLOCK(ctx, res, hash, verbosity)                                               \
  {                                                                                                \
    char*      jpayload = sprintx("\"%B\",\"%B\"", (bytes_t) hash, (bytes_t) verbosity);           \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_GETBLOCK, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                               \
    if (r) return r;                                                                               \
  }
#define FN_GETBLOCK "getblock"

/**
 * Returns the raw transaction data. The returned level of details depends on the argumentÂ verbosity.
 *
 *
 * Parameters:
 *
 *   - bytes_t txid      : (bytes32) The transaction id
 *   - bytes_t verbosity : (int) 0 or false for the hex-encoded data for `txid`, 1 or true for a json object with information about `txid`
 *   - bytes_t blockhash : (bytes32) The block in which to look for the transaction
 * Returns:
 *   - d_token_t* : (btctransaction) - verbose `0` or `false`: a string that is serialized, hex-encoded data for `txid`
 *         - verbose `1` or `false`: an object representing the transaction.
 */
#define TRY_CALL_GETRAWTRANSACTION(ctx, res, txid, verbosity, blockhash)                                             \
  {                                                                                                                  \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\"", (bytes_t) txid, (bytes_t) verbosity, (bytes_t) blockhash); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_GETRAWTRANSACTION, jpayload, NULL, &res, NULL);          \
    _free(jpayload);                                                                                                 \
    if (r) return r;                                                                                                 \
  }
#define FN_GETRAWTRANSACTION "getrawtransaction"

/**
 * Returns a btc address given some inut data and an address type
 *
 *
 * Parameters:
 *
 *   - char* data : (string) This is the data used by the api to generate and address.
 *                  The nature of this parameted changes according to the type of address to generate.
 *                  For "p2pkh" this field should contain a 65-byte btc public key or a 33-byte btc compressed pub key.
 *                  For "p2sh", this field should contain a raw btc locking script.
 *
 *   - char* type : (string) The address type to generate.
 *
 * Returns:
 *   - char* : (string) The encoded btc address
 */
#define TRY_CALL_CREATEADDRESS(ctx, _res, data, type)                                                   \
  {                                                                                                     \
    d_token_t* res;                                                                                     \
    char*      jpayload = sprintx("\"%S\",\"%S\"", (char*)data, (char*)type);                           \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_CREATEADDRESS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                    \
    if (r) return r;                                                                                    \
    _res = d_string(res);                                                                               \
  }
#define FN_CREATEADDRESS "createaddress"

/**
 * Returns a list of addresses or public keys extracted from the outputs of a transaction
 *
 *
 * Parameters:
 *
 *   - char*   tx        : (string) Either the transaction id or the raw btc transaction.
 *                         When this field is 64 characters long (32 bytes), it is treated as transaction id the function will fetch the raw transaction
 *                         from the configured chain with a subrequest.
 *                         When it is bigger than 64 characters (32 bytes), this field is treated as a raw transaction, and no subrequest will be made.
 *
 *   - bytes_t blockhash : (bytes32) The block in which to look for the transaction
 * Returns:
 *   - d_token_t* : (btc_output_address) The addresses and/or public keys extracted fom transaction outputs
 */
#define TRY_CALL_GETADDRESSES(ctx, res, tx, blockhash)                                                 \
  {                                                                                                    \
    char*      jpayload = sprintx("\"%S\",\"%B\"", (char*)tx, (bytes_t) blockhash);                    \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_GETADDRESSES, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                   \
    if (r) return r;                                                                                   \
  }
#define FN_GETADDRESSES "getaddresses"

/**
 * Returns the number of blocks in the longest blockchain.
 *
 * Returns:
 *   - uint64_t : (uint64) the current blockheight
 */
#define TRY_CALL_GETBLOCKCOUNT(ctx, _res)                                                         \
  {                                                                                               \
    d_token_t* res;                                                                               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_GETBLOCKCOUNT, "", NULL, &res, NULL); \
    if (r) return r;                                                                              \
    _res = d_long(res);                                                                           \
  }
#define FN_GETBLOCKCOUNT "getblockcount"

/**
 * Returns hash of block in best-block-chain at height provided.
 *
 *
 * Parameters:
 *
 *   - uint64_t height : (uint64) The block number
 * Returns:
 *   - bytes_t : (bytes32) the current blockheight
 */
#define TRY_CALL_GETBLOCKHASH(ctx, _res, height)                                                       \
  {                                                                                                    \
    d_token_t* res;                                                                                    \
    char*      jpayload = sprintx("\"%U\"", (uint64_t)height);                                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_GETBLOCKHASH, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                   \
    if (r) return r;                                                                                   \
    _res = d_bytes(res);                                                                               \
  }
#define FN_GETBLOCKHASH "getblockhash"

/**
 * Returns the proof-of-work difficulty as a multiple of the minimum difficulty.
 *
 * Returns:
 *   - d_token_t* : (double) - `blocknumber` is a certain number: the difficulty of this block
 *         - `blocknumber` is `latest`, `earliest`, `pending` or empty: the difficulty of the latest block (`actual latest block` minus `in3.finality`)
 */
#define TRY_CALL_GETDIFFICULTY(ctx, res)                                                          \
  {                                                                                               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_GETDIFFICULTY, "", NULL, &res, NULL); \
    if (r) return r;                                                                              \
  }
#define FN_GETDIFFICULTY "getdifficulty"

/**
 * Whenever the client is not able to trust the changes of the target (which is the case if a block can't be found in the verified target cache *and* the value of the target changed more than the client's limit `max_diff`) he will call this method. It will return additional proof data to verify the changes of the target on the side of the client. This is not a standard Bitcoin rpc-method like the other ones, but more like an internal method.
 *
 *
 * Parameters:
 *
 *   - uint64_t target_dap   : (uint64) the number of the difficulty adjustment period (dap) we are looking for
 *   - uint64_t verified_dap : (uint64) the number of the closest already verified dap
 *   - bytes_t  max_diff     : (int) the maximum target difference between 2 verified daps
 *   - bytes_t  max_dap      : (int) the maximum amount of daps between 2 verified daps
 *   - bytes_t  limit        : (int) the maximum amount of daps to return (`0` = no limit) - this is important for embedded devices since returning all daps might be too much for limited memory
 * Returns:
 *   - d_token_t* : ([object Object]) A path of daps from the `verified_dap` to the `target_dap` which fulfils the conditions of `max_diff`, `max_dap` and `limit`. Each dap of the path is a `dap`-object with corresponding proof data.
 */
#define TRY_CALL_BTC_PROOFTARGET(ctx, res, target_dap, verified_dap, max_diff, max_dap, limit)                                                                                 \
  {                                                                                                                                                                            \
    char*      jpayload = sprintx("\"%U\",\"%U\",\"%B\",\"%B\",\"%B\"", (uint64_t)target_dap, (uint64_t)verified_dap, (bytes_t) max_diff, (bytes_t) max_dap, (bytes_t) limit); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_BTC_PROOFTARGET, jpayload, NULL, &res, NULL);                                                                      \
    _free(jpayload);                                                                                                                                                           \
    if (r) return r;                                                                                                                                                           \
  }
#define FN_BTC_PROOFTARGET "btc_proofTarget"

/**
 * Returns the hash of the best (tip) block in the longest blockchain.
 *
 * Returns:
 *   - bytes_t : (bytes32) the hash of the best block
 */
#define TRY_CALL_GETBESTBLOCKHASH(ctx, _res)                                                         \
  {                                                                                                  \
    d_token_t* res;                                                                                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_GETBESTBLOCKHASH, "", NULL, &res, NULL); \
    if (r) return r;                                                                                 \
    _res = d_bytes(res);                                                                             \
  }
#define FN_GETBESTBLOCKHASH "getbestblockhash"

/**
 * signs and sends a transaction to a btc node
 *
 *
 *
 * Parameters:
 *
 *   - uint8_t*   from    : (address) 20-byte btc address to which the "change" from the utxos will be sent
 *   - d_token_t* account : (btc_sign_acc) default eth account used by in3 to sign btc transactions
 *   - d_token_t* outputs : (btc_value) how much and to which adresses we want to send funds
 *   - d_token_t* utxos   : (utxo) the utxos used to provide funds for the transaction
 * Returns:
 *   - bytes_t : (bytes32) the transactionhash
 */
#define TRY_CALL_SENDTRANSACTION(ctx, _res, from, account, outputs, utxos)                                                             \
  {                                                                                                                                    \
    d_token_t* res;                                                                                                                    \
    char*      jpayload = sprintx("\"%B\",%j,%j,%j", bytes(from, 20), (d_token_t*) account, (d_token_t*) outputs, (d_token_t*) utxos); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SENDTRANSACTION, jpayload, NULL, &res, NULL);                              \
    _free(jpayload);                                                                                                                   \
    if (r) return r;                                                                                                                   \
    _res = d_bytes(res);                                                                                                               \
  }
#define FN_SENDTRANSACTION "sendtransaction"

/**
 * sends a transaction to a btc node
 *
 *
 * Parameters:
 *
 *   - char* transaction : (string) the signed raw transaction
 * Returns:
 *   - bytes_t : (bytes32) the transactionhash
 */
#define TRY_CALL_SENDRAWTRANSACTION(ctx, _res, transaction)                                                  \
  {                                                                                                          \
    d_token_t* res;                                                                                          \
    char*      jpayload = sprintx("\"%S\"", (char*)transaction);                                             \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SENDRAWTRANSACTION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
    _res = d_bytes(res);                                                                                     \
  }
#define FN_SENDRAWTRANSACTION "sendrawtransaction"

/**
 * returns thetoken definition for the given token
 *
 *
 * Parameters:
 *
 *   - char* token : (string) the token-name or address
 * Returns:
 *   - d_token_t* : (defi_token) the token definition.
 */
#define TRY_CALL_DEFI_GET_TOKEN(ctx, res, token)                                                         \
  {                                                                                                      \
    char*      jpayload = sprintx("\"%S\"", (char*)token);                                               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_DEFI_GET_TOKEN, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
  }
#define FN_DEFI_GET_TOKEN "defi_get_token"

/**
 * returns all known token definitions
 *
 * Returns:
 *   - d_token_t* : (defi_token) all token definitions according to the tokenlist.
 */
#define TRY_CALL_DEFI_GET_ALL_TOKENS(ctx, res)                                                          \
  {                                                                                                     \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_DEFI_GET_ALL_TOKENS, "", NULL, &res, NULL); \
    if (r) return r;                                                                                    \
  }
#define FN_DEFI_GET_ALL_TOKENS "defi_get_all_tokens"

/**
 * returns the price per token based on the uniswap
 *
 *
 * Parameters:
 *
 *   - char*   tokenIn  : (string) token to pay with
 *   - char*   tokenOut : (string) token to receive
 *   - bytes_t amount   : (uint256) amount of token planned to spend. This information may be used to determine the best price
 * Returns:
 *   - d_token_t* : (defi_uniswap_price) the token price
 */
#define TRY_CALL_DEFI_UNISWAP_GET_PRICE(ctx, res, tokenIn, tokenOut, amount)                                     \
  {                                                                                                              \
    char*      jpayload = sprintx("\"%S\",\"%S\",\"%B\"", (char*)tokenIn, (char*)tokenOut, (bytes_t) amount);    \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_DEFI_UNISWAP_GET_PRICE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                             \
    if (r) return r;                                                                                             \
  }
#define FN_DEFI_UNISWAP_GET_PRICE "defi_uniswap_get_price"

/**
 * returns the address of the pool
 *
 *
 * Parameters:
 *
 *   - char*    tokenIn  : (string) token to pay with
 *   - char*    tokenOut : (string) token to receive
 *   - uint32_t fee      : (uint32) the pool fee
 * Returns:
 *   - uint8_t* : (address) the token address
 */
#define TRY_CALL_DEFI_UNISWAP_GET_POOL_ADDRESS(ctx, _res, tokenIn, tokenOut, fee)                                       \
  {                                                                                                                     \
    d_token_t* res;                                                                                                     \
    char*      jpayload = sprintx("\"%S\",\"%S\",\"%u\"", (char*)tokenIn, (char*)tokenOut, (uint32_t)fee);              \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_DEFI_UNISWAP_GET_POOL_ADDRESS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                    \
    if (r) return r;                                                                                                    \
    _res = d_bytes(res).data;                                                                                           \
  }
#define FN_DEFI_UNISWAP_GET_POOL_ADDRESS "defi_uniswap_get_pool_address"

/**
 * creates a transaction, to swap with a the exact input for as many token as we can get for the output.
 *
 *
 * Parameters:
 *
 *   - char*    tokenIn          : (string) token to pay with
 *   - char*    tokenOut         : (string) token to receive
 *   - bytes_t  amount           : (uint256) amount of input tokens
 *   - uint8_t* wallet           : (address) the wallet or account to be used. I ommited the default-wallet as configured.
 *   - uint8_t* recipient        : (address) recipient of the tokens
 *   - bytes_t  amountOutMinimum : (uint256) minimal amount of tokens to expect. if 0 there is no min limit.
 *   - char*    exec             : (string) the execution level when sending transactions trough the wallet.
 *                                     - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                                     - `sign` - the raw transaction is signed
 *                                     - `send` - the transaction is send and the transactionHash is added
 *                                     - `receipt` - the function will wait until the receipt has been found
 *
 * Returns:
 *   - d_token_t* : (tx_data) Depending on the level, the transaction which needs to be send.
 */
#define TRY_CALL_DEFI_UNISWAP_SWAP_FROM(ctx, res, tokenIn, tokenOut, amount, wallet, recipient, amountOutMinimum, exec)                                                                                                     \
  {                                                                                                                                                                                                                         \
    char*      jpayload = sprintx("\"%S\",\"%S\",\"%B\",\"%B\",\"%B\",\"%B\",\"%S\"", (char*)tokenIn, (char*)tokenOut, (bytes_t) amount, bytes(wallet, 20), bytes(recipient, 20), (bytes_t) amountOutMinimum, (char*)exec); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_DEFI_UNISWAP_SWAP_FROM, jpayload, NULL, &res, NULL);                                                                                                            \
    _free(jpayload);                                                                                                                                                                                                        \
    if (r) return r;                                                                                                                                                                                                        \
  }
#define FN_DEFI_UNISWAP_SWAP_FROM "defi_uniswap_swap_from"

/**
 * transfers eth to weth
 *
 *
 * Parameters:
 *
 *   - bytes_t  amount : (uint256) eth to pay
 *   - uint8_t* wallet : (address) the wallet or account to be used. I ommited the default-wallet as configured.
 *   - char*    exec   : (string) the execution level when sending transactions trough the wallet.
 *                           - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                           - `sign` - the raw transaction is signed
 *                           - `send` - the transaction is send and the transactionHash is added
 *                           - `receipt` - the function will wait until the receipt has been found
 *
 * Returns:
 *   - d_token_t* : (tx_data) Depending on the level, the transaction which needs to be send.
 */
#define TRY_CALL_DEFI_TO_WETH(ctx, res, amount, wallet, exec)                                                \
  {                                                                                                          \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%S\"", (bytes_t) amount, bytes(wallet, 20), (char*)exec); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_DEFI_TO_WETH, jpayload, NULL, &res, NULL);       \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
  }
#define FN_DEFI_TO_WETH "defi_to_weth"

/**
 * transfers weth to eth
 *
 *
 * Parameters:
 *
 *   - bytes_t  amount : (uint256) eth to pay
 *   - uint8_t* wallet : (address) the wallet or account to be used. I ommited the default-wallet as configured.
 *   - char*    exec   : (string) the execution level when sending transactions trough the wallet.
 *                           - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                           - `sign` - the raw transaction is signed
 *                           - `send` - the transaction is send and the transactionHash is added
 *                           - `receipt` - the function will wait until the receipt has been found
 *
 * Returns:
 *   - d_token_t* : (tx_data) Depending on the level, the transaction which needs to be send.
 */
#define TRY_CALL_DEFI_FROM_WETH(ctx, res, amount, wallet, exec)                                              \
  {                                                                                                          \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%S\"", (bytes_t) amount, bytes(wallet, 20), (char*)exec); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_DEFI_FROM_WETH, jpayload, NULL, &res, NULL);     \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
  }
#define FN_DEFI_FROM_WETH "defi_from_weth"

/**
 * approves WETH for the recipient
 *
 *
 * Parameters:
 *
 *   - char*    token     : (string) the token to approve
 *   - bytes_t  amount    : (uint256) eth to approve
 *   - uint8_t* recipient : (address) recipient
 *   - uint8_t* wallet    : (address) the wallet or account to be used. I ommited the default-wallet as configured.
 *   - char*    exec      : (string) the execution level when sending transactions trough the wallet.
 *                              - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                              - `sign` - the raw transaction is signed
 *                              - `send` - the transaction is send and the transactionHash is added
 *                              - `receipt` - the function will wait until the receipt has been found
 *
 * Returns:
 *   - d_token_t* : (tx_data) Depending on the level, the transaction which needs to be send.
 */
#define TRY_CALL_DEFI_APPROVE(ctx, res, token, amount, recipient, wallet, exec)                                                                                \
  {                                                                                                                                                            \
    char*      jpayload = sprintx("\"%S\",\"%B\",\"%B\",\"%B\",\"%S\"", (char*)token, (bytes_t) amount, bytes(recipient, 20), bytes(wallet, 20), (char*)exec); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_DEFI_APPROVE, jpayload, NULL, &res, NULL);                                                         \
    _free(jpayload);                                                                                                                                           \
    if (r) return r;                                                                                                                                           \
  }
#define FN_DEFI_APPROVE "defi_approve"

/**
 * returns the allowed tokens
 *
 *
 * Parameters:
 *
 *   - char*    token     : (string) the token to approve
 *   - uint8_t* recipient : (address) recipient
 *   - uint8_t* wallet    : (address) the owner of the token
 *   - bool     dec       : (bool) if true the value will be displayed as decimal
 * Returns:
 *   - bytes_t : (uint256) the allowed balance
 */
#define TRY_CALL_DEFI_GET_ALLOWANCE(ctx, _res, token, recipient, wallet, dec)                                                   \
  {                                                                                                                             \
    d_token_t* res;                                                                                                             \
    char*      jpayload = sprintx("\"%S\",\"%B\",\"%B\",%i", (char*)token, bytes(recipient, 20), bytes(wallet, 20), (int) dec); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_DEFI_GET_ALLOWANCE, jpayload, NULL, &res, NULL);                    \
    _free(jpayload);                                                                                                            \
    if (r) return r;                                                                                                            \
    _res = d_bytes(res);                                                                                                        \
  }
#define FN_DEFI_GET_ALLOWANCE "defi_get_allowance"

/**
 * Returns the amount of tokens of token type `id` owned by `account`. Requirements: - `account` cannot be the zero address.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* account  : (address) account
 *   - bytes_t  id       : (uint256) id
 * Returns:
 *   - bytes_t : (uint256) the resulting data structure
 */
#define TRY_CALL_ERC1155_BALANCE_OF(ctx, _res, contract, account, id)                                             \
  {                                                                                                               \
    d_token_t* res;                                                                                               \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\"", bytes(contract, 20), bytes(account, 20), (bytes_t) id); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC1155_BALANCE_OF, jpayload, NULL, &res, NULL);      \
    _free(jpayload);                                                                                              \
    if (r) return r;                                                                                              \
    _res = d_bytes(res);                                                                                          \
  }
#define FN_ERC1155_BALANCE_OF "erc1155_balance_of"

/**
 * xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}. Requirements: - `accounts` and `ids` must have the same length.
 *
 *
 * Parameters:
 *
 *   - uint8_t*   contract : (address) the address of the contract
 *   - d_token_t* accounts : (address) accounts
 *   - d_token_t* ids      : (uint256) ids
 * Returns:
 *   - bytes_t : (uint256[]) the resulting data structure
 */
#define TRY_CALL_ERC1155_BALANCE_OF_BATCH(ctx, _res, contract, accounts, ids)                                      \
  {                                                                                                                \
    d_token_t* res;                                                                                                \
    char*      jpayload = sprintx("\"%B\",%j,%j", bytes(contract, 20), (d_token_t*) accounts, (d_token_t*) ids);   \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC1155_BALANCE_OF_BATCH, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                               \
    if (r) return r;                                                                                               \
    _res = d_bytes(res);                                                                                           \
  }
#define FN_ERC1155_BALANCE_OF_BATCH "erc1155_balance_of_batch"

/**
 * Returns true if `operator` is approved to transfer ``account``'s tokens. See {setApprovalForAll}.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* account  : (address) account
 *   - uint8_t* operator : (address) operator
 * Returns:
 *   - bool : (bool) the resulting data structure
 */
#define TRY_CALL_ERC1155_IS_APPROVED_FOR_ALL(ctx, _res, contract, account, operator)                                     \
  {                                                                                                                      \
    d_token_t* res;                                                                                                      \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\"", bytes(contract, 20), bytes(account, 20), bytes(operator, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC1155_IS_APPROVED_FOR_ALL, jpayload, NULL, &res, NULL);    \
    _free(jpayload);                                                                                                     \
    if (r) return r;                                                                                                     \
    _res = d_int(res);                                                                                                   \
  }
#define FN_ERC1155_IS_APPROVED_FOR_ALL "erc1155_is_approved_for_all"

/**
 * xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}. Emits a {TransferBatch} event. Requirements: - `ids` and `amounts` must have the same length. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.
 *
 *
 * Parameters:
 *
 *   - uint8_t*   contract : (address) the address of the contract
 *   - uint8_t*   from     : (address) from
 *   - uint8_t*   to       : (address) to
 *   - d_token_t* ids      : (uint256) ids
 *   - d_token_t* amounts  : (uint256) amounts
 *   - bytes_t    data     : (bytes) data
 *   - char*      exec     : (string) the execution level when sending transactions trough the wallet.
 *                               - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                               - `sign` - the raw transaction is signed
 *                               - `send` - the transaction is send and the transactionHash is added
 *                               - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t*   wallet   : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC1155_SAFE_BATCH_TRANSFER_FROM(ctx, res, contract, from, to, ids, amounts, data, exec, wallet)                                                                                                                  \
  {                                                                                                                                                                                                                                \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\",%j,%j,\"%B\",\"%S\",\"%B\"", bytes(contract, 20), bytes(from, 20), bytes(to, 20), (d_token_t*) ids, (d_token_t*) amounts, (bytes_t) data, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC1155_SAFE_BATCH_TRANSFER_FROM, jpayload, NULL, &res, NULL);                                                                                                         \
    _free(jpayload);                                                                                                                                                                                                               \
    if (r) return r;                                                                                                                                                                                                               \
  }
#define FN_ERC1155_SAFE_BATCH_TRANSFER_FROM "erc1155_safe_batch_transfer_from"

/**
 * Transfers `amount` tokens of token type `id` from `from` to `to`. Emits a {TransferSingle} event. Requirements: - `to` cannot be the zero address. - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}. - `from` must have a balance of tokens of type `id` of at least `amount`. - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* from     : (address) from
 *   - uint8_t* to       : (address) to
 *   - bytes_t  id       : (uint256) id
 *   - bytes_t  amount   : (uint256) amount
 *   - bytes_t  data     : (bytes) data
 *   - char*    exec     : (string) the execution level when sending transactions trough the wallet.
 *                             - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                             - `sign` - the raw transaction is signed
 *                             - `send` - the transaction is send and the transactionHash is added
 *                             - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t* wallet   : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC1155_SAFE_TRANSFER_FROM(ctx, res, contract, from, to, id, amount, data, exec, wallet)                                                                                                                          \
  {                                                                                                                                                                                                                                \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\",\"%B\",\"%B\",\"%B\",\"%S\",\"%B\"", bytes(contract, 20), bytes(from, 20), bytes(to, 20), (bytes_t) id, (bytes_t) amount, (bytes_t) data, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC1155_SAFE_TRANSFER_FROM, jpayload, NULL, &res, NULL);                                                                                                               \
    _free(jpayload);                                                                                                                                                                                                               \
    if (r) return r;                                                                                                                                                                                                               \
  }
#define FN_ERC1155_SAFE_TRANSFER_FROM "erc1155_safe_transfer_from"

/**
 * Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`, Emits an {ApprovalForAll} event. Requirements: - `operator` cannot be the caller.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* operator : (address) operator
 *   - bool     approved : (bool) approved
 *   - char*    exec     : (string) the execution level when sending transactions trough the wallet.
 *                             - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                             - `sign` - the raw transaction is signed
 *                             - `send` - the transaction is send and the transactionHash is added
 *                             - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t* wallet   : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC1155_SET_APPROVAL_FOR_ALL(ctx, res, contract, operator, approved, exec, wallet)                                                            \
  {                                                                                                                                                            \
    char*      jpayload = sprintx("\"%B\",\"%B\",%i,\"%S\",\"%B\"", bytes(contract, 20), bytes(operator, 20), (int) approved, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC1155_SET_APPROVAL_FOR_ALL, jpayload, NULL, &res, NULL);                                         \
    _free(jpayload);                                                                                                                                           \
    if (r) return r;                                                                                                                                           \
  }
#define FN_ERC1155_SET_APPROVAL_FOR_ALL "erc1155_set_approval_for_all"

/**
 * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract    : (address) the address of the contract
 *   - bytes_t  interfaceId : (bytes4) interfaceId
 * Returns:
 *   - bool : (bool) the resulting data structure
 */
#define TRY_CALL_ERC1155_SUPPORTS_INTERFACE(ctx, _res, contract, interfaceId)                                        \
  {                                                                                                                  \
    d_token_t* res;                                                                                                  \
    char*      jpayload = sprintx("\"%B\",\"%B\"", bytes(contract, 20), (bytes_t) interfaceId);                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC1155_SUPPORTS_INTERFACE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                 \
    if (r) return r;                                                                                                 \
    _res = d_int(res);                                                                                               \
  }
#define FN_ERC1155_SUPPORTS_INTERFACE "erc1155_supports_interface"

/**
 * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract    : (address) the address of the contract
 *   - bytes_t  interfaceId : (bytes4) interfaceId
 * Returns:
 *   - bool : (bool) the resulting data structure
 */
#define TRY_CALL_ERC165_SUPPORTS_INTERFACE(ctx, _res, contract, interfaceId)                                        \
  {                                                                                                                 \
    d_token_t* res;                                                                                                 \
    char*      jpayload = sprintx("\"%B\",\"%B\"", bytes(contract, 20), (bytes_t) interfaceId);                     \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC165_SUPPORTS_INTERFACE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                \
    if (r) return r;                                                                                                \
    _res = d_int(res);                                                                                              \
  }
#define FN_ERC165_SUPPORTS_INTERFACE "erc165_supports_interface"

/**
 * Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* owner    : (address) owner
 *   - uint8_t* spender  : (address) spender
 * Returns:
 *   - bytes_t : (uint256) the resulting data structure
 */
#define TRY_CALL_ERC20_ALLOWANCE(ctx, _res, contract, owner, spender)                                                 \
  {                                                                                                                   \
    d_token_t* res;                                                                                                   \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\"", bytes(contract, 20), bytes(owner, 20), bytes(spender, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC20_ALLOWANCE, jpayload, NULL, &res, NULL);             \
    _free(jpayload);                                                                                                  \
    if (r) return r;                                                                                                  \
    _res = d_bytes(res);                                                                                              \
  }
#define FN_ERC20_ALLOWANCE "erc20_allowance"

/**
 * Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* spender  : (address) spender
 *   - bytes_t  amount   : (uint256) amount
 *   - char*    exec     : (string) the execution level when sending transactions trough the wallet.
 *                             - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                             - `sign` - the raw transaction is signed
 *                             - `send` - the transaction is send and the transactionHash is added
 *                             - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t* wallet   : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC20_APPROVE(ctx, res, contract, spender, amount, exec, wallet)                                                                                   \
  {                                                                                                                                                                 \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\",\"%S\",\"%B\"", bytes(contract, 20), bytes(spender, 20), (bytes_t) amount, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC20_APPROVE, jpayload, NULL, &res, NULL);                                                             \
    _free(jpayload);                                                                                                                                                \
    if (r) return r;                                                                                                                                                \
  }
#define FN_ERC20_APPROVE "erc20_approve"

/**
 * Returns the amount of tokens owned by `account`.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* account  : (address) account
 * Returns:
 *   - bytes_t : (uint256) the resulting data structure
 */
#define TRY_CALL_ERC20_BALANCE_OF(ctx, _res, contract, account)                                            \
  {                                                                                                        \
    d_token_t* res;                                                                                        \
    char*      jpayload = sprintx("\"%B\",\"%B\"", bytes(contract, 20), bytes(account, 20));               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC20_BALANCE_OF, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                       \
    if (r) return r;                                                                                       \
    _res = d_bytes(res);                                                                                   \
  }
#define FN_ERC20_BALANCE_OF "erc20_balance_of"

/**
 * Returns the decimals places of the token.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 * Returns:
 *   - uint8_t : (uint8) the resulting data structure
 */
#define TRY_CALL_ERC20_DECIMALS(ctx, _res, contract)                                                     \
  {                                                                                                      \
    d_token_t* res;                                                                                      \
    char*      jpayload = sprintx("\"%B\"", bytes(contract, 20));                                        \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC20_DECIMALS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
    _res = (uint32_t) d_long(res);                                                                       \
  }
#define FN_ERC20_DECIMALS "erc20_decimals"

/**
 * Returns the name of the token.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 * Returns:
 *   - char* : (string) the resulting data structure
 */
#define TRY_CALL_ERC20_NAME(ctx, _res, contract)                                                     \
  {                                                                                                  \
    d_token_t* res;                                                                                  \
    char*      jpayload = sprintx("\"%B\"", bytes(contract, 20));                                    \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC20_NAME, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                 \
    if (r) return r;                                                                                 \
    _res = d_string(res);                                                                            \
  }
#define FN_ERC20_NAME "erc20_name"

/**
 * Returns the symbol of the token.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 * Returns:
 *   - char* : (string) the resulting data structure
 */
#define TRY_CALL_ERC20_SYMBOL(ctx, _res, contract)                                                     \
  {                                                                                                    \
    d_token_t* res;                                                                                    \
    char*      jpayload = sprintx("\"%B\"", bytes(contract, 20));                                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC20_SYMBOL, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                   \
    if (r) return r;                                                                                   \
    _res = d_string(res);                                                                              \
  }
#define FN_ERC20_SYMBOL "erc20_symbol"

/**
 * Returns the amount of tokens in existence.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 * Returns:
 *   - bytes_t : (uint256) the resulting data structure
 */
#define TRY_CALL_ERC20_TOTAL_SUPPLY(ctx, _res, contract)                                                     \
  {                                                                                                          \
    d_token_t* res;                                                                                          \
    char*      jpayload = sprintx("\"%B\"", bytes(contract, 20));                                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC20_TOTAL_SUPPLY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
    _res = d_bytes(res);                                                                                     \
  }
#define FN_ERC20_TOTAL_SUPPLY "erc20_total_supply"

/**
 * Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* to       : (address) to
 *   - bytes_t  amount   : (uint256) amount
 *   - char*    exec     : (string) the execution level when sending transactions trough the wallet.
 *                             - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                             - `sign` - the raw transaction is signed
 *                             - `send` - the transaction is send and the transactionHash is added
 *                             - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t* wallet   : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC20_TRANSFER(ctx, res, contract, to, amount, exec, wallet)                                                                                  \
  {                                                                                                                                                            \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\",\"%S\",\"%B\"", bytes(contract, 20), bytes(to, 20), (bytes_t) amount, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC20_TRANSFER, jpayload, NULL, &res, NULL);                                                       \
    _free(jpayload);                                                                                                                                           \
    if (r) return r;                                                                                                                                           \
  }
#define FN_ERC20_TRANSFER "erc20_transfer"

/**
 * Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* from     : (address) from
 *   - uint8_t* to       : (address) to
 *   - bytes_t  amount   : (uint256) amount
 *   - char*    exec     : (string) the execution level when sending transactions trough the wallet.
 *                             - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                             - `sign` - the raw transaction is signed
 *                             - `send` - the transaction is send and the transactionHash is added
 *                             - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t* wallet   : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC20_TRANSFER_FROM(ctx, res, contract, from, to, amount, exec, wallet)                                                                                               \
  {                                                                                                                                                                                    \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\",\"%B\",\"%S\",\"%B\"", bytes(contract, 20), bytes(from, 20), bytes(to, 20), (bytes_t) amount, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC20_TRANSFER_FROM, jpayload, NULL, &res, NULL);                                                                          \
    _free(jpayload);                                                                                                                                                                   \
    if (r) return r;                                                                                                                                                                   \
  }
#define FN_ERC20_TRANSFER_FROM "erc20_transfer_from"

/**
 * Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of exchange. The royalty amount is denominated and should be payed in that same unit of exchange.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract  : (address) the address of the contract
 *   - bytes_t  tokenId   : (uint256) tokenId
 *   - bytes_t  salePrice : (uint256) salePrice
 * Returns:
 *   - d_token_t* : ([object Object]) the resulting data structure
 */
#define TRY_CALL_ERC2981_ROYALTY_INFO(ctx, res, contract, tokenId, salePrice)                                           \
  {                                                                                                                     \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\"", bytes(contract, 20), (bytes_t) tokenId, (bytes_t) salePrice); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC2981_ROYALTY_INFO, jpayload, NULL, &res, NULL);          \
    _free(jpayload);                                                                                                    \
    if (r) return r;                                                                                                    \
  }
#define FN_ERC2981_ROYALTY_INFO "erc2981_royalty_info"

/**
 * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract    : (address) the address of the contract
 *   - bytes_t  interfaceId : (bytes4) interfaceId
 * Returns:
 *   - bool : (bool) the resulting data structure
 */
#define TRY_CALL_ERC2981_SUPPORTS_INTERFACE(ctx, _res, contract, interfaceId)                                        \
  {                                                                                                                  \
    d_token_t* res;                                                                                                  \
    char*      jpayload = sprintx("\"%B\",\"%B\"", bytes(contract, 20), (bytes_t) interfaceId);                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC2981_SUPPORTS_INTERFACE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                 \
    if (r) return r;                                                                                                 \
    _res = d_int(res);                                                                                               \
  }
#define FN_ERC2981_SUPPORTS_INTERFACE "erc2981_supports_interface"

/**
 * Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* to       : (address) to
 *   - bytes_t  tokenId  : (uint256) tokenId
 *   - char*    exec     : (string) the execution level when sending transactions trough the wallet.
 *                             - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                             - `sign` - the raw transaction is signed
 *                             - `send` - the transaction is send and the transactionHash is added
 *                             - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t* wallet   : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC721_APPROVE(ctx, res, contract, to, tokenId, exec, wallet)                                                                                  \
  {                                                                                                                                                             \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\",\"%S\",\"%B\"", bytes(contract, 20), bytes(to, 20), (bytes_t) tokenId, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC721_APPROVE, jpayload, NULL, &res, NULL);                                                        \
    _free(jpayload);                                                                                                                                            \
    if (r) return r;                                                                                                                                            \
  }
#define FN_ERC721_APPROVE "erc721_approve"

/**
 * Returns the number of tokens in ``owner``'s account.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* owner    : (address) owner
 * Returns:
 *   - bytes_t : (uint256) the resulting data structure
 */
#define TRY_CALL_ERC721_BALANCE_OF(ctx, _res, contract, owner)                                              \
  {                                                                                                         \
    d_token_t* res;                                                                                         \
    char*      jpayload = sprintx("\"%B\",\"%B\"", bytes(contract, 20), bytes(owner, 20));                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC721_BALANCE_OF, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                        \
    if (r) return r;                                                                                        \
    _res = d_bytes(res);                                                                                    \
  }
#define FN_ERC721_BALANCE_OF "erc721_balance_of"

/**
 * Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - bytes_t  tokenId  : (uint256) tokenId
 * Returns:
 *   - uint8_t* : (address) the resulting data structure
 */
#define TRY_CALL_ERC721_GET_APPROVED(ctx, _res, contract, tokenId)                                            \
  {                                                                                                           \
    d_token_t* res;                                                                                           \
    char*      jpayload = sprintx("\"%B\",\"%B\"", bytes(contract, 20), (bytes_t) tokenId);                   \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC721_GET_APPROVED, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
    _res = d_bytes(res).data;                                                                                 \
  }
#define FN_ERC721_GET_APPROVED "erc721_get_approved"

/**
 * Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* owner    : (address) owner
 *   - uint8_t* operator : (address) operator
 * Returns:
 *   - bool : (bool) the resulting data structure
 */
#define TRY_CALL_ERC721_IS_APPROVED_FOR_ALL(ctx, _res, contract, owner, operator)                                      \
  {                                                                                                                    \
    d_token_t* res;                                                                                                    \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\"", bytes(contract, 20), bytes(owner, 20), bytes(operator, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC721_IS_APPROVED_FOR_ALL, jpayload, NULL, &res, NULL);   \
    _free(jpayload);                                                                                                   \
    if (r) return r;                                                                                                   \
    _res = d_int(res);                                                                                                 \
  }
#define FN_ERC721_IS_APPROVED_FOR_ALL "erc721_is_approved_for_all"

/**
 * Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - bytes_t  tokenId  : (uint256) tokenId
 * Returns:
 *   - uint8_t* : (address) the resulting data structure
 */
#define TRY_CALL_ERC721_OWNER_OF(ctx, _res, contract, tokenId)                                            \
  {                                                                                                       \
    d_token_t* res;                                                                                       \
    char*      jpayload = sprintx("\"%B\",\"%B\"", bytes(contract, 20), (bytes_t) tokenId);               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC721_OWNER_OF, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                      \
    if (r) return r;                                                                                      \
    _res = d_bytes(res).data;                                                                             \
  }
#define FN_ERC721_OWNER_OF "erc721_owner_of"

/**
 * Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* from     : (address) from
 *   - uint8_t* to       : (address) to
 *   - bytes_t  tokenId  : (uint256) tokenId
 *   - bytes_t  data     : (bytes) data
 *   - char*    exec     : (string) the execution level when sending transactions trough the wallet.
 *                             - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                             - `sign` - the raw transaction is signed
 *                             - `send` - the transaction is send and the transactionHash is added
 *                             - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t* wallet   : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC721_SAFE_TRANSFER_FROM(ctx, res, contract, from, to, tokenId, data, exec, wallet)                                                                                                          \
  {                                                                                                                                                                                                            \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\",\"%B\",\"%B\",\"%S\",\"%B\"", bytes(contract, 20), bytes(from, 20), bytes(to, 20), (bytes_t) tokenId, (bytes_t) data, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC721_SAFE_TRANSFER_FROM, jpayload, NULL, &res, NULL);                                                                                            \
    _free(jpayload);                                                                                                                                                                                           \
    if (r) return r;                                                                                                                                                                                           \
  }
#define FN_ERC721_SAFE_TRANSFER_FROM "erc721_safe_transfer_from"

/**
 * Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract  : (address) the address of the contract
 *   - uint8_t* operator  : (address) operator
 *   - bool     _approved : (bool) _approved
 *   - char*    exec      : (string) the execution level when sending transactions trough the wallet.
 *                              - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                              - `sign` - the raw transaction is signed
 *                              - `send` - the transaction is send and the transactionHash is added
 *                              - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t* wallet    : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC721_SET_APPROVAL_FOR_ALL(ctx, res, contract, operator, _approved, exec, wallet)                                                             \
  {                                                                                                                                                             \
    char*      jpayload = sprintx("\"%B\",\"%B\",%i,\"%S\",\"%B\"", bytes(contract, 20), bytes(operator, 20), (int) _approved, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC721_SET_APPROVAL_FOR_ALL, jpayload, NULL, &res, NULL);                                           \
    _free(jpayload);                                                                                                                                            \
    if (r) return r;                                                                                                                                            \
  }
#define FN_ERC721_SET_APPROVAL_FOR_ALL "erc721_set_approval_for_all"

/**
 * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract    : (address) the address of the contract
 *   - bytes_t  interfaceId : (bytes4) interfaceId
 * Returns:
 *   - bool : (bool) the resulting data structure
 */
#define TRY_CALL_ERC721_SUPPORTS_INTERFACE(ctx, _res, contract, interfaceId)                                        \
  {                                                                                                                 \
    d_token_t* res;                                                                                                 \
    char*      jpayload = sprintx("\"%B\",\"%B\"", bytes(contract, 20), (bytes_t) interfaceId);                     \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC721_SUPPORTS_INTERFACE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                \
    if (r) return r;                                                                                                \
    _res = d_int(res);                                                                                              \
  }
#define FN_ERC721_SUPPORTS_INTERFACE "erc721_supports_interface"

/**
 * Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* from     : (address) from
 *   - uint8_t* to       : (address) to
 *   - bytes_t  tokenId  : (uint256) tokenId
 *   - char*    exec     : (string) the execution level when sending transactions trough the wallet.
 *                             - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                             - `sign` - the raw transaction is signed
 *                             - `send` - the transaction is send and the transactionHash is added
 *                             - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t* wallet   : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC721_TRANSFER_FROM(ctx, res, contract, from, to, tokenId, exec, wallet)                                                                                              \
  {                                                                                                                                                                                     \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\",\"%B\",\"%S\",\"%B\"", bytes(contract, 20), bytes(from, 20), bytes(to, 20), (bytes_t) tokenId, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC721_TRANSFER_FROM, jpayload, NULL, &res, NULL);                                                                          \
    _free(jpayload);                                                                                                                                                                    \
    if (r) return r;                                                                                                                                                                    \
  }
#define FN_ERC721_TRANSFER_FROM "erc721_transfer_from"

/**
 * Make an account an operator of the caller. See {isOperatorFor}. Emits an {AuthorizedOperator} event. Requirements - `operator` cannot be calling address.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* operator : (address) operator
 *   - char*    exec     : (string) the execution level when sending transactions trough the wallet.
 *                             - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                             - `sign` - the raw transaction is signed
 *                             - `send` - the transaction is send and the transactionHash is added
 *                             - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t* wallet   : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC777_AUTHORIZE_OPERATOR(ctx, res, contract, operator, exec, wallet)                                                      \
  {                                                                                                                                         \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%S\",\"%B\"", bytes(contract, 20), bytes(operator, 20), (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC777_AUTHORIZE_OPERATOR, jpayload, NULL, &res, NULL);                         \
    _free(jpayload);                                                                                                                        \
    if (r) return r;                                                                                                                        \
  }
#define FN_ERC777_AUTHORIZE_OPERATOR "erc777_authorize_operator"

/**
 * Returns the amount of tokens owned by an account (`owner`).
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* owner    : (address) owner
 * Returns:
 *   - bytes_t : (uint256) the resulting data structure
 */
#define TRY_CALL_ERC777_BALANCE_OF(ctx, _res, contract, owner)                                              \
  {                                                                                                         \
    d_token_t* res;                                                                                         \
    char*      jpayload = sprintx("\"%B\",\"%B\"", bytes(contract, 20), bytes(owner, 20));                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC777_BALANCE_OF, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                        \
    if (r) return r;                                                                                        \
    _res = d_bytes(res);                                                                                    \
  }
#define FN_ERC777_BALANCE_OF "erc777_balance_of"

/**
 * Destroys `amount` tokens from the caller's account, reducing the total supply. If a send hook is registered for the caller, the corresponding function will be called with `data` and empty `operatorData`. See {IERC777Sender}. Emits a {Burned} event. Requirements - the caller must have at least `amount` tokens.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - bytes_t  amount   : (uint256) amount
 *   - bytes_t  data     : (bytes) data
 *   - char*    exec     : (string) the execution level when sending transactions trough the wallet.
 *                             - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                             - `sign` - the raw transaction is signed
 *                             - `send` - the transaction is send and the transactionHash is added
 *                             - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t* wallet   : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC777_BURN(ctx, res, contract, amount, data, exec, wallet)                                                                                    \
  {                                                                                                                                                             \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\",\"%S\",\"%B\"", bytes(contract, 20), (bytes_t) amount, (bytes_t) data, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC777_BURN, jpayload, NULL, &res, NULL);                                                           \
    _free(jpayload);                                                                                                                                            \
    if (r) return r;                                                                                                                                            \
  }
#define FN_ERC777_BURN "erc777_burn"

/**
 * Returns the list of default operators. These accounts are operators for all token holders, even if {authorizeOperator} was never called on them. This list is immutable, but individual holders may revoke these via {revokeOperator}, in which case {isOperatorFor} will return false.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 * Returns:
 *   - d_token_t* : (address[]) the resulting data structure
 */
#define TRY_CALL_ERC777_DEFAULT_OPERATORS(ctx, res, contract)                                                      \
  {                                                                                                                \
    char*      jpayload = sprintx("\"%B\"", bytes(contract, 20));                                                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC777_DEFAULT_OPERATORS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                               \
    if (r) return r;                                                                                               \
  }
#define FN_ERC777_DEFAULT_OPERATORS "erc777_default_operators"

/**
 * Returns the smallest part of the token that is not divisible. This means all token operations (creation, movement and destruction) must have amounts that are a multiple of this number. For most token contracts, this value will equal 1.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 * Returns:
 *   - bytes_t : (uint256) the resulting data structure
 */
#define TRY_CALL_ERC777_GRANULARITY(ctx, _res, contract)                                                     \
  {                                                                                                          \
    d_token_t* res;                                                                                          \
    char*      jpayload = sprintx("\"%B\"", bytes(contract, 20));                                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC777_GRANULARITY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
    _res = d_bytes(res);                                                                                     \
  }
#define FN_ERC777_GRANULARITY "erc777_granularity"

/**
 * Returns true if an account is an operator of `tokenHolder`. Operators can send and burn tokens on behalf of their owners. All accounts are their own operator. See {operatorSend} and {operatorBurn}.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract    : (address) the address of the contract
 *   - uint8_t* operator    : (address) operator
 *   - uint8_t* tokenHolder : (address) tokenHolder
 * Returns:
 *   - bool : (bool) the resulting data structure
 */
#define TRY_CALL_ERC777_IS_OPERATOR_FOR(ctx, _res, contract, operator, tokenHolder)                                          \
  {                                                                                                                          \
    d_token_t* res;                                                                                                          \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\"", bytes(contract, 20), bytes(operator, 20), bytes(tokenHolder, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC777_IS_OPERATOR_FOR, jpayload, NULL, &res, NULL);             \
    _free(jpayload);                                                                                                         \
    if (r) return r;                                                                                                         \
    _res = d_int(res);                                                                                                       \
  }
#define FN_ERC777_IS_OPERATOR_FOR "erc777_is_operator_for"

/**
 * Returns the name of the token.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 * Returns:
 *   - char* : (string) the resulting data structure
 */
#define TRY_CALL_ERC777_NAME(ctx, _res, contract)                                                     \
  {                                                                                                   \
    d_token_t* res;                                                                                   \
    char*      jpayload = sprintx("\"%B\"", bytes(contract, 20));                                     \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC777_NAME, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                  \
    if (r) return r;                                                                                  \
    _res = d_string(res);                                                                             \
  }
#define FN_ERC777_NAME "erc777_name"

/**
 * Destroys `amount` tokens from `account`, reducing the total supply. The caller must be an operator of `account`. If a send hook is registered for `account`, the corresponding function will be called with `data` and `operatorData`. See {IERC777Sender}. Emits a {Burned} event. Requirements - `account` cannot be the zero address. - `account` must have at least `amount` tokens. - the caller must be an operator for `account`.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract     : (address) the address of the contract
 *   - uint8_t* account      : (address) account
 *   - bytes_t  amount       : (uint256) amount
 *   - bytes_t  data         : (bytes) data
 *   - bytes_t  operatorData : (bytes) operatorData
 *   - char*    exec         : (string) the execution level when sending transactions trough the wallet.
 *                                 - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                                 - `sign` - the raw transaction is signed
 *                                 - `send` - the transaction is send and the transactionHash is added
 *                                 - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t* wallet       : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC777_OPERATOR_BURN(ctx, res, contract, account, amount, data, operatorData, exec, wallet)                                                                                                              \
  {                                                                                                                                                                                                                       \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\",\"%B\",\"%B\",\"%S\",\"%B\"", bytes(contract, 20), bytes(account, 20), (bytes_t) amount, (bytes_t) data, (bytes_t) operatorData, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC777_OPERATOR_BURN, jpayload, NULL, &res, NULL);                                                                                                            \
    _free(jpayload);                                                                                                                                                                                                      \
    if (r) return r;                                                                                                                                                                                                      \
  }
#define FN_ERC777_OPERATOR_BURN "erc777_operator_burn"

/**
 * Moves `amount` tokens from `sender` to `recipient`. The caller must be an operator of `sender`. If send or receive hooks are registered for `sender` and `recipient`, the corresponding functions will be called with `data` and `operatorData`. See {IERC777Sender} and {IERC777Recipient}. Emits a {Sent} event. Requirements - `sender` cannot be the zero address. - `sender` must have at least `amount` tokens. - the caller must be an operator for `sender`. - `recipient` cannot be the zero address. - if `recipient` is a contract, it must implement the {IERC777Recipient} interface.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract     : (address) the address of the contract
 *   - uint8_t* sender       : (address) sender
 *   - uint8_t* recipient    : (address) recipient
 *   - bytes_t  amount       : (uint256) amount
 *   - bytes_t  data         : (bytes) data
 *   - bytes_t  operatorData : (bytes) operatorData
 *   - char*    exec         : (string) the execution level when sending transactions trough the wallet.
 *                                 - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                                 - `sign` - the raw transaction is signed
 *                                 - `send` - the transaction is send and the transactionHash is added
 *                                 - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t* wallet       : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC777_OPERATOR_SEND(ctx, res, contract, sender, recipient, amount, data, operatorData, exec, wallet)                                                                                                                                \
  {                                                                                                                                                                                                                                                   \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\",\"%B\",\"%B\",\"%B\",\"%S\",\"%B\"", bytes(contract, 20), bytes(sender, 20), bytes(recipient, 20), (bytes_t) amount, (bytes_t) data, (bytes_t) operatorData, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC777_OPERATOR_SEND, jpayload, NULL, &res, NULL);                                                                                                                                        \
    _free(jpayload);                                                                                                                                                                                                                                  \
    if (r) return r;                                                                                                                                                                                                                                  \
  }
#define FN_ERC777_OPERATOR_SEND "erc777_operator_send"

/**
 * Revoke an account's operator status for the caller. See {isOperatorFor} and {defaultOperators}. Emits a {RevokedOperator} event. Requirements - `operator` cannot be calling address.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 *   - uint8_t* operator : (address) operator
 *   - char*    exec     : (string) the execution level when sending transactions trough the wallet.
 *                             - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                             - `sign` - the raw transaction is signed
 *                             - `send` - the transaction is send and the transactionHash is added
 *                             - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t* wallet   : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC777_REVOKE_OPERATOR(ctx, res, contract, operator, exec, wallet)                                                         \
  {                                                                                                                                         \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%S\",\"%B\"", bytes(contract, 20), bytes(operator, 20), (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC777_REVOKE_OPERATOR, jpayload, NULL, &res, NULL);                            \
    _free(jpayload);                                                                                                                        \
    if (r) return r;                                                                                                                        \
  }
#define FN_ERC777_REVOKE_OPERATOR "erc777_revoke_operator"

/**
 * Moves `amount` tokens from the caller's account to `recipient`. If send or receive hooks are registered for the caller and `recipient`, the corresponding functions will be called with `data` and empty `operatorData`. See {IERC777Sender} and {IERC777Recipient}. Emits a {Sent} event. Requirements - the caller must have at least `amount` tokens. - `recipient` cannot be the zero address. - if `recipient` is a contract, it must implement the {IERC777Recipient} interface.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract  : (address) the address of the contract
 *   - uint8_t* recipient : (address) recipient
 *   - bytes_t  amount    : (uint256) amount
 *   - bytes_t  data      : (bytes) data
 *   - char*    exec      : (string) the execution level when sending transactions trough the wallet.
 *                              - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                              - `sign` - the raw transaction is signed
 *                              - `send` - the transaction is send and the transactionHash is added
 *                              - `receipt` - the function will wait until the receipt has been found
 *   - uint8_t* wallet    : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) The transaction data. Depending on the execl_level different properties will be defined.
 */
#define TRY_CALL_ERC777_SEND(ctx, res, contract, recipient, amount, data, exec, wallet)                                                                                                      \
  {                                                                                                                                                                                          \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\",\"%B\",\"%S\",\"%B\"", bytes(contract, 20), bytes(recipient, 20), (bytes_t) amount, (bytes_t) data, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC777_SEND, jpayload, NULL, &res, NULL);                                                                                        \
    _free(jpayload);                                                                                                                                                                         \
    if (r) return r;                                                                                                                                                                         \
  }
#define FN_ERC777_SEND "erc777_send"

/**
 * Returns the symbol of the token, usually a shorter version of the name.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 * Returns:
 *   - char* : (string) the resulting data structure
 */
#define TRY_CALL_ERC777_SYMBOL(ctx, _res, contract)                                                     \
  {                                                                                                     \
    d_token_t* res;                                                                                     \
    char*      jpayload = sprintx("\"%B\"", bytes(contract, 20));                                       \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC777_SYMBOL, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                    \
    if (r) return r;                                                                                    \
    _res = d_string(res);                                                                               \
  }
#define FN_ERC777_SYMBOL "erc777_symbol"

/**
 * Returns the amount of tokens in existence.
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract : (address) the address of the contract
 * Returns:
 *   - bytes_t : (uint256) the resulting data structure
 */
#define TRY_CALL_ERC777_TOTAL_SUPPLY(ctx, _res, contract)                                                     \
  {                                                                                                           \
    d_token_t* res;                                                                                           \
    char*      jpayload = sprintx("\"%B\"", bytes(contract, 20));                                             \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ERC777_TOTAL_SUPPLY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
    _res = d_bytes(res);                                                                                      \
  }
#define FN_ERC777_TOTAL_SUPPLY "erc777_total_supply"

/**
 * analyzes a transaaction before signing and produces a human readbale explaination what the transaction will do.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t tx : (bytes32) the transactionhash
 * Returns:
 *   - d_token_t* : (tx_message) a collection of messages describing the action in the transaction.
 */
#define TRY_CALL_IN3_ANALYZE_BY_TXHASH(ctx, res, tx)                                                            \
  {                                                                                                             \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) tx);                                                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_ANALYZE_BY_TXHASH, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                            \
    if (r) return r;                                                                                            \
  }
#define FN_IN3_ANALYZE_BY_TXHASH "in3_analyze_by_txhash"

/**
 * analyzes a transaction before signing and produces a human readbale explaination what the transaction will do.
 *
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx     : (eth_transaction) the transactiondata.
 *   - uint8_t*   sender : (address) the address of the sender who would sign the tx.
 * Returns:
 *   - d_token_t* : (tx_message) a collection of messages describing the action in the transaction.
 */
#define TRY_CALL_IN3_ANALYZE_TX(ctx, res, tx, sender)                                                    \
  {                                                                                                      \
    char*      jpayload = sprintx("%j,\"%B\"", (d_token_t*) tx, bytes(sender, 20));                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_ANALYZE_TX, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
  }
#define FN_IN3_ANALYZE_TX "in3_analyze_tx"

/**
 * analyzes a raw transaaction before signing and produces a human readbale explaination what the transaction will do.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t  tx     : (bytes) the transactiondata. if the data are 32bytes it will be handled as transactionhash, if not the raw transaction is expected.
 *   - uint8_t* sender : (address) the address of the sender who would sign the tx. This is needed if the tx is a unsigned raw transaction in order to verify the balances and nonce.
 * Returns:
 *   - d_token_t* : (tx_message) a collection of messages describing the action in the transaction.
 */
#define TRY_CALL_IN3_ANALYZE_RAWTX(ctx, res, tx, sender)                                                    \
  {                                                                                                         \
    char*      jpayload = sprintx("\"%B\",\"%B\"", (bytes_t) tx, bytes(sender, 20));                        \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_ANALYZE_RAWTX, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                        \
    if (r) return r;                                                                                        \
  }
#define FN_IN3_ANALYZE_RAWTX "in3_analyze_rawtx"

/**
 * returns the current gasPrice in wei per gas
 *
 * Returns:
 *   - uint64_t : (uint64) the current gasPrice in wei per gas
 */
#define TRY_CALL_ETH_GASPRICE(ctx, _res)                                                         \
  {                                                                                              \
    d_token_t* res;                                                                              \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GASPRICE, "", NULL, &res, NULL); \
    if (r) return r;                                                                             \
    _res = d_long(res);                                                                          \
  }
#define FN_ETH_GASPRICE "eth_gasPrice"

/**
 * base fee per gas and transaction effective priority fee per gas history for the requested block range if available.
 * The range between headBlock-4 and headBlock is guaranteed to be available while retrieving data from the pending block and older history are optional to support.
 * For pre-EIP-1559 blocks the gas prices are returned as rewards and zeroes are returned for the base fee per gas
 *
 *
 *
 * Parameters:
 *
 *   - uint64_t   blockCount        : (uint64) Number of blocks in the requested range. Between 1 and 1024 blocks can be requested in a single query. Less than requested may be returned if not all blocks are available.
 *   - uint64_t   newestBlock       : (uint64) the Highest blockNumber or one of `latest`, `earliest`or `pending`
 *   - d_token_t* rewardPercentiles : (double) A monotonically increasing list of percentile values to sample from each block's effective priority fees per gas in ascending order, weighted by gas used.
 * Returns:
 *   - d_token_t* : ([object Object]) Fee history for the returned block range. This can be a subsection of the requested range if not all blocks are available.
 */
#define TRY_CALL_ETH_FEEHISTORY(ctx, res, blockCount, newestBlock, rewardPercentiles)                                               \
  {                                                                                                                                 \
    char*      jpayload = sprintx("\"%U\",\"%U\",%j", (uint64_t)blockCount, (uint64_t)newestBlock, (d_token_t*) rewardPercentiles); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_FEEHISTORY, jpayload, NULL, &res, NULL);                            \
    _free(jpayload);                                                                                                                \
    if (r) return r;                                                                                                                \
  }
#define FN_ETH_FEEHISTORY "eth_feeHistory"

/**
 * returns the number of the most recent block.
 *
 * See [eth_blockNumber](https://eth.wiki/json-rpc/API#eth_blockNumber) for spec.
 *
 * No proof returned, since there is none, but the client should verify the result by comparing it to the current blocks returned from others.
 * With the `blockTime` from the chainspec, including a tolerance, the current blocknumber may be checked if in the proposed range.
 *
 *
 * Returns:
 *   - uint64_t : (uint64) the highest known blocknumber
 */
#define TRY_CALL_ETH_BLOCKNUMBER(ctx, _res)                                                         \
  {                                                                                                 \
    d_token_t* res;                                                                                 \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_BLOCKNUMBER, "", NULL, &res, NULL); \
    if (r) return r;                                                                                \
    _res = d_long(res);                                                                             \
  }
#define FN_ETH_BLOCKNUMBER "eth_blockNumber"

/**
 * returns information about a block by block number.
 *
 * See [eth_getBlockByNumber](https://eth.wiki/json-rpc/API#eth_getBlockByNumber) for spec.
 *
 *
 *
 * Parameters:
 *
 *   - uint64_t blockNumber : (uint64) the blockNumber or one of `latest`, `earliest`or `pending`
 *   - bool     fullTx      : (bool) if true the full transactions are contained in the result.
 * Returns:
 *   - d_token_t* : (eth_blockdata) the blockdata, or in case the block with that number does not exist, `null` will be returned.
 */
#define TRY_CALL_ETH_GETBLOCKBYNUMBER(ctx, res, blockNumber, fullTx)                                           \
  {                                                                                                            \
    char*      jpayload = sprintx("\"%U\",%i", (uint64_t)blockNumber, (int) fullTx);                           \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GETBLOCKBYNUMBER, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                           \
    if (r) return r;                                                                                           \
  }
#define FN_ETH_GETBLOCKBYNUMBER "eth_getBlockByNumber"

/**
 * Returns information about a block by hash.
 *
 * See [eth_getBlockByHash](https://eth.wiki/json-rpc/API#eth_getBlockByHash) for spec.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t blockHash : (bytes32) the blockHash of the block
 *   - bool    fullTx    : (bool) if true the full transactions are contained in the result.
 * Returns:
 *   - d_token_t* : (eth_blockdata) the blockdata, or in case the block with that number does not exist, `null` will be returned.
 */
#define TRY_CALL_ETH_GETBLOCKBYHASH(ctx, res, blockHash, fullTx)                                             \
  {                                                                                                          \
    char*      jpayload = sprintx("\"%B\",%i", (bytes_t) blockHash, (int) fullTx);                           \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GETBLOCKBYHASH, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
  }
#define FN_ETH_GETBLOCKBYHASH "eth_getBlockByHash"

/**
 * returns the number of transactions. For Spec, see [eth_getBlockTransactionCountByHash](https://eth.wiki/json-rpc/API#eth_getBlockTransactionCountByHash).
 *
 *
 * Parameters:
 *
 *   - bytes_t blockHash : (bytes32) the blockHash of the block
 * Returns:
 *   - bytes_t : (int) the number of transactions in the block
 */
#define TRY_CALL_ETH_GETBLOCKTRANSACTIONCOUNTBYHASH(ctx, _res, blockHash)                                                    \
  {                                                                                                                          \
    d_token_t* res;                                                                                                          \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) blockHash);                                                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GETBLOCKTRANSACTIONCOUNTBYHASH, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                         \
    if (r) return r;                                                                                                         \
    _res = d_bytes(res);                                                                                                     \
  }
#define FN_ETH_GETBLOCKTRANSACTIONCOUNTBYHASH "eth_getBlockTransactionCountByHash"

/**
 * returns the number of transactions. For Spec, see [eth_getBlockTransactionCountByNumber](https://eth.wiki/json-rpc/API#eth_getBlockTransactionCountByNumber).
 *
 *
 * Parameters:
 *
 *   - uint64_t blockNumber : (uint64) the blockNumber of the block
 * Returns:
 *   - bytes_t : (int) the number of transactions in the block
 */
#define TRY_CALL_ETH_GETBLOCKTRANSACTIONCOUNTBYNUMBER(ctx, _res, blockNumber)                                                  \
  {                                                                                                                            \
    d_token_t* res;                                                                                                            \
    char*      jpayload = sprintx("\"%U\"", (uint64_t)blockNumber);                                                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GETBLOCKTRANSACTIONCOUNTBYNUMBER, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                           \
    if (r) return r;                                                                                                           \
    _res = d_bytes(res);                                                                                                       \
  }
#define FN_ETH_GETBLOCKTRANSACTIONCOUNTBYNUMBER "eth_getBlockTransactionCountByNumber"

/**
 * returns the number of uncles. For Spec, see [eth_getUncleCountByBlockHash](https://eth.wiki/json-rpc/API#eth_getUncleCountByBlockHash).
 *
 *
 * Parameters:
 *
 *   - bytes_t blockHash : (bytes32) the blockHash of the block
 * Returns:
 *   - bytes_t : (int) the number of uncles
 */
#define TRY_CALL_ETH_GETUNCLECOUNTBYBLOCKHASH(ctx, _res, blockHash)                                                    \
  {                                                                                                                    \
    d_token_t* res;                                                                                                    \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) blockHash);                                                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GETUNCLECOUNTBYBLOCKHASH, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                   \
    if (r) return r;                                                                                                   \
    _res = d_bytes(res);                                                                                               \
  }
#define FN_ETH_GETUNCLECOUNTBYBLOCKHASH "eth_getUncleCountByBlockHash"

/**
 * returns the number of uncles. For Spec, see [eth_getUncleCountByBlockNumber](https://eth.wiki/json-rpc/API#eth_getUncleCountByBlockNumber).
 *
 *
 * Parameters:
 *
 *   - uint64_t blockNumber : (uint64) the blockNumber of the block
 * Returns:
 *   - bytes_t : (int) the number of uncles
 */
#define TRY_CALL_ETH_GETUNCLECOUNTBYBLOCKNUMBER(ctx, _res, blockNumber)                                                  \
  {                                                                                                                      \
    d_token_t* res;                                                                                                      \
    char*      jpayload = sprintx("\"%U\"", (uint64_t)blockNumber);                                                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GETUNCLECOUNTBYBLOCKNUMBER, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                     \
    if (r) return r;                                                                                                     \
    _res = d_bytes(res);                                                                                                 \
  }
#define FN_ETH_GETUNCLECOUNTBYBLOCKNUMBER "eth_getUncleCountByBlockNumber"

/**
 * returns the transaction data.
 *
 * See JSON-RPC-Spec for [eth_getTransactionByBlockHashAndIndex](https://eth.wiki/json-rpc/API#eth_getTransactionByBlockHashAndIndex) for more details.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t blockHash : (bytes32) the blockhash containing the transaction.
 *   - bytes_t index     : (int) the transactionIndex
 * Returns:
 *   - d_token_t* : (eth_transactiondata) the transactiondata or `null` if it does not exist
 */
#define TRY_CALL_ETH_GETTRANSACTIONBYBLOCKHASHANDINDEX(ctx, res, blockHash, index)                                              \
  {                                                                                                                             \
    char*      jpayload = sprintx("\"%B\",\"%B\"", (bytes_t) blockHash, (bytes_t) index);                                       \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GETTRANSACTIONBYBLOCKHASHANDINDEX, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                            \
    if (r) return r;                                                                                                            \
  }
#define FN_ETH_GETTRANSACTIONBYBLOCKHASHANDINDEX "eth_getTransactionByBlockHashAndIndex"

/**
 * returns the transaction data.
 *
 * See JSON-RPC-Spec for [eth_getTransactionByBlockNumberAndIndex](https://eth.wiki/json-rpc/API#eth_getTransactionByBlockNumberAndIndex) for more details.
 *
 *
 *
 * Parameters:
 *
 *   - uint64_t blockNumber : (uint64) the block number containing the transaction.
 *   - bytes_t  index       : (int) the transactionIndex
 * Returns:
 *   - d_token_t* : (eth_transactiondata) the transactiondata or `null` if it does not exist
 */
#define TRY_CALL_ETH_GETTRANSACTIONBYBLOCKNUMBERANDINDEX(ctx, res, blockNumber, index)                                            \
  {                                                                                                                               \
    char*      jpayload = sprintx("\"%U\",\"%B\"", (uint64_t)blockNumber, (bytes_t) index);                                       \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GETTRANSACTIONBYBLOCKNUMBERANDINDEX, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                              \
    if (r) return r;                                                                                                              \
  }
#define FN_ETH_GETTRANSACTIONBYBLOCKNUMBERANDINDEX "eth_getTransactionByBlockNumberAndIndex"

/**
 * returns the transaction data.
 *
 * See JSON-RPC-Spec for [eth_getTransactionByHash](https://eth.wiki/json-rpc/API#eth_getTransactionByHash) for more details.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t txHash : (bytes32) the transactionHash of the transaction.
 * Returns:
 *   - d_token_t* : (eth_transactiondata) the transactiondata or `null` if it does not exist
 */
#define TRY_CALL_ETH_GETTRANSACTIONBYHASH(ctx, res, txHash)                                                        \
  {                                                                                                                \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) txHash);                                                     \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GETTRANSACTIONBYHASH, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                               \
    if (r) return r;                                                                                               \
  }
#define FN_ETH_GETTRANSACTIONBYHASH "eth_getTransactionByHash"

/**
 * searches for events matching the given criteria. See [eth_getLogs](https://eth.wiki/json-rpc/API#eth_getLogs) for the spec.
 *
 *
 * Parameters:
 *
 *   - d_token_t* filter : ([object Object]) The filter criteria for the events.
 * Returns:
 *   - d_token_t* : (ethlog) array with all found event matching the specified filter
 */
#define TRY_CALL_ETH_GETLOGS(ctx, res, filter)                                                        \
  {                                                                                                   \
    char*      jpayload = sprintx("%j", (d_token_t*) filter);                                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GETLOGS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                  \
    if (r) return r;                                                                                  \
  }
#define FN_ETH_GETLOGS "eth_getLogs"

/**
 * gets the balance of an account for a given block
 *
 *
 * Parameters:
 *
 *   - uint8_t* account : (address) address of the account
 *   - uint64_t block   : (uint64) the blockNumber or `latest`
 * Returns:
 *   - bytes_t : (uint256) the balance
 */
#define TRY_CALL_ETH_GETBALANCE(ctx, _res, account, block)                                               \
  {                                                                                                      \
    d_token_t* res;                                                                                      \
    char*      jpayload = sprintx("\"%B\",\"%U\"", bytes(account, 20), (uint64_t)block);                 \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GETBALANCE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
    _res = d_bytes(res);                                                                                 \
  }
#define FN_ETH_GETBALANCE "eth_getBalance"

/**
 * gets the nonce or number of transaction sent from this account at a given block
 *
 *
 * Parameters:
 *
 *   - uint8_t* account : (address) address of the account
 *   - uint64_t block   : (uint64) the blockNumber or  `latest`
 * Returns:
 *   - uint64_t : (uint64) the nonce
 */
#define TRY_CALL_ETH_GETTRANSACTIONCOUNT(ctx, _res, account, block)                                               \
  {                                                                                                               \
    d_token_t* res;                                                                                               \
    char*      jpayload = sprintx("\"%B\",\"%U\"", bytes(account, 20), (uint64_t)block);                          \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GETTRANSACTIONCOUNT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                              \
    if (r) return r;                                                                                              \
    _res = d_long(res);                                                                                           \
  }
#define FN_ETH_GETTRANSACTIONCOUNT "eth_getTransactionCount"

/**
 * gets the code of a given contract
 *
 *
 * Parameters:
 *
 *   - uint8_t* account : (address) address of the account
 *   - uint64_t block   : (uint64) the blockNumber or `latest`
 * Returns:
 *   - bytes_t : (bytes) the code as hex
 */
#define TRY_CALL_ETH_GETCODE(ctx, _res, account, block)                                               \
  {                                                                                                   \
    d_token_t* res;                                                                                   \
    char*      jpayload = sprintx("\"%B\",\"%U\"", bytes(account, 20), (uint64_t)block);              \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GETCODE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                  \
    if (r) return r;                                                                                  \
    _res = d_bytes(res);                                                                              \
  }
#define FN_ETH_GETCODE "eth_getCode"

/**
 * gets the storage value of a given key
 *
 *
 * Parameters:
 *
 *   - uint8_t* account : (address) address of the account
 *   - bytes_t  key     : (bytes32) key to look for
 *   - uint64_t block   : (uint64) the blockNumber or`latest`
 * Returns:
 *   - bytes_t : (bytes) the value of the storage slot.
 */
#define TRY_CALL_ETH_GETSTORAGEAT(ctx, _res, account, key, block)                                              \
  {                                                                                                            \
    d_token_t* res;                                                                                            \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%U\"", bytes(account, 20), (bytes_t) key, (uint64_t)block); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GETSTORAGEAT, jpayload, NULL, &res, NULL);     \
    _free(jpayload);                                                                                           \
    if (r) return r;                                                                                           \
    _res = d_bytes(res);                                                                                       \
  }
#define FN_ETH_GETSTORAGEAT "eth_getStorageAt"

/**
 * signs and sends a Transaction
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx : (eth_transaction) the transactiondata to send
 * Returns:
 *   - bytes_t : (bytes) the transactionHash
 */
#define TRY_CALL_ETH_SENDTRANSACTION(ctx, _res, tx)                                                           \
  {                                                                                                           \
    d_token_t* res;                                                                                           \
    char*      jpayload = sprintx("%j", (d_token_t*) tx);                                                     \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_SENDTRANSACTION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
    _res = d_bytes(res);                                                                                      \
  }
#define FN_ETH_SENDTRANSACTION "eth_sendTransaction"

/**
 * signs and sends a Transaction, but then waits until the transaction receipt can be verified. Depending on the finality of the nodes, this may take a while, since only final blocks will be signed by the nodes.
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx : (eth_transaction) the transactiondata to send
 * Returns:
 *   - d_token_t* : (eth_transactionReceipt) the transactionReceipt
 */
#define TRY_CALL_ETH_SENDTRANSACTIONANDWAIT(ctx, res, tx)                                                            \
  {                                                                                                                  \
    char*      jpayload = sprintx("%j", (d_token_t*) tx);                                                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_SENDTRANSACTIONANDWAIT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                 \
    if (r) return r;                                                                                                 \
  }
#define FN_ETH_SENDTRANSACTIONANDWAIT "eth_sendTransactionAndWait"

/**
 * sends or broadcasts a prviously signed raw transaction. See [eth_sendRawTransaction](https://eth.wiki/json-rpc/API#eth_sendRawTransaction)
 *
 *
 * Parameters:
 *
 *   - bytes_t tx : (bytes) the raw signed transactiondata to send
 * Returns:
 *   - bytes_t : (bytes32) the transactionhash
 */
#define TRY_CALL_ETH_SENDRAWTRANSACTION(ctx, _res, tx)                                                           \
  {                                                                                                              \
    d_token_t* res;                                                                                              \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) tx);                                                       \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_SENDRAWTRANSACTION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                             \
    if (r) return r;                                                                                             \
    _res = d_bytes(res);                                                                                         \
  }
#define FN_ETH_SENDRAWTRANSACTION "eth_sendRawTransaction"

/**
 * calculates the gas needed to execute a transaction. for spec see [eth_estimateGas](https://eth.wiki/json-rpc/API#eth_estimateGas)
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx    : (eth_transaction) the tx-object, which is the same as specified in [eth_sendTransaction](https://eth.wiki/json-rpc/API#eth_sendTransaction).
 *   - uint64_t   block : (uint64) the blockNumber or  `latest`
 * Returns:
 *   - uint64_t : (uint64) the amount of gass needed.
 */
#define TRY_CALL_ETH_ESTIMATEGAS(ctx, _res, tx, block)                                                    \
  {                                                                                                       \
    d_token_t* res;                                                                                       \
    char*      jpayload = sprintx("%j,\"%U\"", (d_token_t*) tx, (uint64_t)block);                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_ESTIMATEGAS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                      \
    if (r) return r;                                                                                      \
    _res = d_long(res);                                                                                   \
  }
#define FN_ETH_ESTIMATEGAS "eth_estimateGas"

/**
 * calls a function of a contract (or simply executes the evm opcodes) and returns the result. for spec see [eth_call](https://eth.wiki/json-rpc/API#eth_call)
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx    : (eth_transaction) the tx-object, which is the same as specified in [eth_sendTransaction](https://eth.wiki/json-rpc/API#eth_sendTransaction).
 *   - uint64_t   block : (uint64) the blockNumber or  `latest`
 * Returns:
 *   - char* : (string) the abi-encoded result of the function.
 */
#define TRY_CALL_ETH_CALL(ctx, _res, tx, block)                                                    \
  {                                                                                                \
    d_token_t* res;                                                                                \
    char*      jpayload = sprintx("%j,\"%U\"", (d_token_t*) tx, (uint64_t)block);                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_CALL, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                               \
    if (r) return r;                                                                               \
    _res = d_string(res);                                                                          \
  }
#define FN_ETH_CALL "eth_call"

/**
 * The Receipt of a Transaction. For Details, see [eth_getTransactionReceipt](https://eth.wiki/json-rpc/API#eth_gettransactionreceipt).
 *
 *
 * Parameters:
 *
 *   - bytes_t txHash : (bytes32) the transactionHash
 * Returns:
 *   - d_token_t* : (eth_transactionReceipt) the TransactionReceipt or `null`  if it does not exist.
 */
#define TRY_CALL_ETH_GETTRANSACTIONRECEIPT(ctx, res, txHash)                                                        \
  {                                                                                                                 \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) txHash);                                                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_GETTRANSACTIONRECEIPT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                \
    if (r) return r;                                                                                                \
  }
#define FN_ETH_GETTRANSACTIONRECEIPT "eth_getTransactionReceipt"

/**
 * reads the data from a contract and returns it as multisig definition.
 *
 *
 * Parameters:
 *
 *   - uint8_t* account : (address) the address of the wallet
 * Returns:
 *   - d_token_t* : (ms_def) the wallet-configuration
 */
#define TRY_CALL_L1_WALLET_READ(ctx, res, account)                                                       \
  {                                                                                                      \
    char*      jpayload = sprintx("\"%B\"", bytes(account, 20));                                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_L1_WALLET_READ, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
  }
#define FN_L1_WALLET_READ "l1_wallet_read"

/**
 * reads the history and all events for the wallet.
 *
 *
 * Parameters:
 *
 *   - bool     force_update : (bool) if true the history will also be update otherwise it will be taken from the cache and only created if it does not exist yet
 *   - bool     only_new     : (bool) if true, only new events will be returned
 *   - uint8_t* account      : (address) the address of the wallet
 * Returns:
 *   - d_token_t* : (wallet_tx) a array with all events since the creation of the wallet.
 */
#define TRY_CALL_L1_WALLET_HISTORY(ctx, res, force_update, only_new, account)                               \
  {                                                                                                         \
    char*      jpayload = sprintx("%i,%i,\"%B\"", (int) force_update, (int) only_new, bytes(account, 20));  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_L1_WALLET_HISTORY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                        \
    if (r) return r;                                                                                        \
  }
#define FN_L1_WALLET_HISTORY "l1_wallet_history"

/**
 * converts and decodes a eth-log-entry in a event.
 *
 *
 * Parameters:
 *
 *   - d_token_t* log       : (ethlog) the log entry as returned by eth_getLogs
 *   - uint64_t   timestamp : (uint64) the unix timestamp of the event
 *   - uint32_t   chain_id  : (uint32) the chain_id to be used
 * Returns:
 *   - d_token_t* : (wallet_tx) the event
 */
#define TRY_CALL_L1_WALLET_EVENT_FROM_LOG(ctx, res, log, timestamp, chain_id)                                      \
  {                                                                                                                \
    char*      jpayload = sprintx("%j,\"%U\",\"%u\"", (d_token_t*) log, (uint64_t)timestamp, (uint32_t)chain_id);  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_L1_WALLET_EVENT_FROM_LOG, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                               \
    if (r) return r;                                                                                               \
  }
#define FN_L1_WALLET_EVENT_FROM_LOG "l1_wallet_event_from_log"

/**
 * returns the balance for the specified account or wallet
 *
 *
 * Parameters:
 *
 *   - char*    token  : (string) The name or address of the token or NULL (or "ETH") if eth-balance is requested.
 *   - uint8_t* wallet : (address) the wallet or account to be used. I ommited the default-wallet as configured.
 * Returns:
 *   - bytes_t : (uint256) the current balance
 */
#define TRY_CALL_L1_WALLET_GET_BALANCE(ctx, _res, token, wallet)                                                \
  {                                                                                                             \
    d_token_t* res;                                                                                             \
    char*      jpayload = sprintx("\"%S\",\"%B\"", (char*)token, bytes(wallet, 20));                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_L1_WALLET_GET_BALANCE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                            \
    if (r) return r;                                                                                            \
    _res = d_bytes(res);                                                                                        \
  }
#define FN_L1_WALLET_GET_BALANCE "l1_wallet_get_balance"

/**
 * executes or prepares a transaction for a wallet.
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx     : (tx_data) the description of the transaction. As minimum only the inputs are needed.
 *                         But in order to sign with multiple parties the definition can be passed to combined multiple signatures
 *
 *   - char*      exec   : (string) the execution level when sending transactions trough the wallet.
 *                             - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                             - `sign` - the raw transaction is signed
 *                             - `send` - the transaction is send and the transactionHash is added
 *                             - `receipt` - the function will wait until the receipt has been found
 *
 *   - uint8_t*   wallet : (address) the wallet to be used. If ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) the transaction-state
 */
#define TRY_CALL_L1_WALLET_EXEC(ctx, res, tx, exec, wallet)                                              \
  {                                                                                                      \
    char*      jpayload = sprintx("%j,\"%S\",\"%B\"", (d_token_t*) tx, (char*)exec, bytes(wallet, 20));  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_L1_WALLET_EXEC, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
  }
#define FN_L1_WALLET_EXEC "l1_wallet_exec"

/**
 * deploys a wallet on layer1. This function will send the transaction with either the default-wallet (or first wallet ) or the first registered signer account.
 * It will wait until the transaction is mined. In order to deploy contract you need to configure the mater-copies in the config by stting the `wallet_deploy`- object like
 *
 * ```js
 * {
 *   "wallet_deploy": {
 *     "creator": "0xaa8c54c65c14f132804f0809bdbef19970673709",
 *     "master_copy": "0xc73248bb521c3331e4efedbb0560e806302024fb",
 *     "add_module": "0x846A192315882ca369125F82E64e368858663898",
 *     "master_copy_custody": "0x937c53Cad1619a996645165129620eF2853c76B0",
 *     "multisend": "0xD473Ac22bF22EE68cB8D3CA529BC60864613e0eD"
 *   }
 * }
 * ```
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t    threshold : (int) the threshhold of the multisig, which must be reached in order to execute any transaction.
 *   - d_token_t* owners    : (string) array of owner-addresses. Each address may use a prefix to indicate the role (`I`: Initiator, `A`: Approver, `C`: Challenger).
 *   - d_token_t* modules   : (ms_def) the moduledefinitions
 *   - d_token_t* txparams  : (tx_input) the transaction-arguemnts that should be used for the deployment-tx. Currently supported are contain `gasPrice` , `gas`  and `nonce` . If passed as object, they will be used.
 * Returns:
 *   - d_token_t* : (wallet_update) the wallert-definition with the deployed address.
 */
#define TRY_CALL_L1_WALLET_DEPLOY(ctx, res, threshold, owners, modules, txparams)                                                            \
  {                                                                                                                                          \
    char*      jpayload = sprintx("\"%B\",%j,%j,%j", (bytes_t) threshold, (d_token_t*) owners, (d_token_t*) modules, (d_token_t*) txparams); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_L1_WALLET_DEPLOY, jpayload, NULL, &res, NULL);                                   \
    _free(jpayload);                                                                                                                         \
    if (r) return r;                                                                                                                         \
  }
#define FN_L1_WALLET_DEPLOY "l1_wallet_deploy"

/**
 * deploys a previously configured wallet (`sdk.wallets.add(...)` or just as part of `sdk.create({ wallets: [{...}]})`  ) on layer1. This function will send the transaction with either the default-wallet (or first wallet ) or the first registered signer account.
 * It will wait until the transaction is mined. In order to deploy contract you need to configure the mater-copies in the config by stting the `wallet_deploy`- object like
 *
 * ```js
 * {
 *   "wallet_deploy": {
 *     "creator": "0xaa8c54c65c14f132804f0809bdbef19970673709",
 *     "master_copy": "0xc73248bb521c3331e4efedbb0560e806302024fb",
 *     "add_module": "0x846A192315882ca369125F82E64e368858663898",
 *     "master_copy_custody": "0x937c53Cad1619a996645165129620eF2853c76B0",
 *     "multisend": "0xD473Ac22bF22EE68cB8D3CA529BC60864613e0eD"
 *   }
 * }
 * ```
 *
 *
 *
 * Parameters:
 *
 *   - uint8_t*   address  : (address) the address of the wallet, which must exist in the config.
 *   - d_token_t* txparams : (tx_input) the transaction-arguemnts that should be used for the deployment-tx. Currently supported are contain `gasPrice` , `gas`  and `nonce` . If passed as object, they will be used.
 * Returns:
 *   - d_token_t* : (wallet_update) the wallert-definition with the deployed address.
 */
#define TRY_CALL_L1_WALLET_DEPLOY_FROM_CONFIG(ctx, res, address, txparams)                                             \
  {                                                                                                                    \
    char*      jpayload = sprintx("\"%B\",%j", bytes(address, 20), (d_token_t*) txparams);                             \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_L1_WALLET_DEPLOY_FROM_CONFIG, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                   \
    if (r) return r;                                                                                                   \
  }
#define FN_L1_WALLET_DEPLOY_FROM_CONFIG "l1_wallet_deploy_from_config"

/**
 * Starts a recovery process to replace a lost key with a new key.
 *
 * This requires a signer registered matching at least one of the recovery keys in the wallet.
 *
 *
 *
 * Parameters:
 *
 *   - uint8_t* old_owner    : (address) The address of the owner which should be replaced
 *   - uint8_t* new_owner    : (address) The address of the new owner
 *   - uint8_t* recovery_key : (address) The address of the recovery key used. If null, then  this will be detected based on the current registered signers.
 *   - uint8_t* wallet       : (address) the wallet or account to be used. I ommited the default-wallet as configured.
 *   - char*    exec         : (string) the execution level when sending transactions trough the wallet.
 *                                 - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                                 - `sign` - the raw transaction is signed
 *                                 - `send` - the transaction is send and the transactionHash is added
 *                                 - `receipt` - the function will wait until the receipt has been found
 *
 * Returns:
 *   - d_token_t* : (tx_data) the tx_data with the resulting tx.
 */
#define TRY_CALL_L1_WALLET_RECOVER(ctx, res, old_owner, new_owner, recovery_key, wallet, exec)                                                                                \
  {                                                                                                                                                                           \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\",\"%B\",\"%S\"", bytes(old_owner, 20), bytes(new_owner, 20), bytes(recovery_key, 20), bytes(wallet, 20), (char*)exec); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_L1_WALLET_RECOVER, jpayload, NULL, &res, NULL);                                                                   \
    _free(jpayload);                                                                                                                                                          \
    if (r) return r;                                                                                                                                                          \
  }
#define FN_L1_WALLET_RECOVER "l1_wallet_recover"

/**
 * Checks for multisig for any ongoing recovery-process and reacts by creating a transaction.
 * If one or mor owner key is challenged and should be replaced, but this sdk has a signer for this key registered, it will use it and create a transaction to stop it.
 * If the challenge was started by recovery key wuth a signer registered in the sdk and the challenge interval has passed the final transaction to replace the key will be created.
 *
 *
 *
 * Parameters:
 *
 *   - uint8_t* wallet : (address) the wallet or account to be used. I ommited the default-wallet as configured.
 *   - char*    exec   : (string) the execution level when sending transactions trough the wallet.
 *                           - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                           - `sign` - the raw transaction is signed
 *                           - `send` - the transaction is send and the transactionHash is added
 *                           - `receipt` - the function will wait until the receipt has been found
 *
 * Returns:
 *   - d_token_t* : (tx_data) a array of transactions. Depending on the level, those transactions are just prepared or even executed.
 */
#define TRY_CALL_L1_WALLET_UPDATE_RECOVERY(ctx, res, wallet, exec)                                                  \
  {                                                                                                                 \
    char*      jpayload = sprintx("\"%B\",\"%S\"", bytes(wallet, 20), (char*)exec);                                 \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_L1_WALLET_UPDATE_RECOVERY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                \
    if (r) return r;                                                                                                \
  }
#define FN_L1_WALLET_UPDATE_RECOVERY "l1_wallet_update_recovery"

/**
 * Fetches the data for a requested ipfs-hash. If the node is not able to resolve the hash or find the data a error should be reported.
 *
 *
 * Parameters:
 *
 *   - char* ipfshash : (string) the ipfs multi hash
 *   - char* encoding : (string) the encoding used for the response. ( `hex` , `base64` or `utf8`)
 * Returns:
 *   - bytes_t : (bytes) the content matching the requested hash encoded in the defined encoding.
 */
#define TRY_CALL_IPFS_GET(ctx, _res, ipfshash, encoding)                                           \
  {                                                                                                \
    d_token_t* res;                                                                                \
    char*      jpayload = sprintx("\"%S\",\"%S\"", (char*)ipfshash, (char*)encoding);              \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IPFS_GET, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                               \
    if (r) return r;                                                                               \
    _res = d_bytes(res);                                                                           \
  }
#define FN_IPFS_GET "ipfs_get"

/**
 * Stores ipfs-content to the ipfs network.
 * Important! As a client there is no garuantee that a node made this content available. ( just like `eth_sendRawTransaction` will only broadcast it).
 * Even if the node stores the content there is no gurantee it will do it forever.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t data     : (bytes) the content encoded with the specified encoding.
 *   - char*   encoding : (string) the encoding used for the request. ( `hex` , `base64` or `utf8`)
 * Returns:
 *   - char* : (string) the ipfs multi hash
 */
#define TRY_CALL_IPFS_PUT(ctx, _res, data, encoding)                                               \
  {                                                                                                \
    d_token_t* res;                                                                                \
    char*      jpayload = sprintx("\"%B\",\"%S\"", (bytes_t) data, (char*)encoding);               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IPFS_PUT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                               \
    if (r) return r;                                                                               \
    _res = d_string(res);                                                                          \
  }
#define FN_IPFS_PUT "ipfs_put"

/**
 * lists all keys of the authenticated user.
 *
 *
 * Returns:
 *   - d_token_t* : (kms_key) the keys for the user of the authenticated user
 */
#define TRY_CALL_KMS_LIST_KEYS(ctx, res)                                                          \
  {                                                                                               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_KMS_LIST_KEYS, "", NULL, &res, NULL); \
    if (r) return r;                                                                              \
  }
#define FN_KMS_LIST_KEYS "kms_list_keys"

/**
 * creates a new key. if the user has permission to create keys for himself, the userId will be taken from the authentification, otherwise it will be required to set the userIdy
 *
 *
 *
 * Parameters:
 *
 *   - d_token_t* create_key_attributes : (kms_key_creation_args) the data for the key creation
 *   - d_token_t* signature             : (kms_signature) signatures for policy challenge
 * Returns:
 *   - d_token_t* : (kms_key) the crated key
 */
#define TRY_CALL_KMS_CREATE_KEY(ctx, res, create_key_attributes, signature)                              \
  {                                                                                                      \
    char*      jpayload = sprintx("%j,%j", (d_token_t*) create_key_attributes, (d_token_t*) signature);  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_KMS_CREATE_KEY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
  }
#define FN_KMS_CREATE_KEY "kms_create_key"

/**
 * returns the keys for the given id.
 *
 *
 *
 * Parameters:
 *
 *   - char* id : (string) the internal id or the public address, since this makes it easier for the SDK to find the key, if only the address is known.
 * Returns:
 *   - d_token_t* : (kms_key) the key for the given id
 */
#define TRY_CALL_KMS_GET_KEY(ctx, res, id)                                                            \
  {                                                                                                   \
    char*      jpayload = sprintx("\"%S\"", (char*)id);                                               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_KMS_GET_KEY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                  \
    if (r) return r;                                                                                  \
  }
#define FN_KMS_GET_KEY "kms_get_key"

/**
 * returns the keys for the given id.
 *
 *
 *
 * Parameters:
 *
 *   - char*      id        : (string) the internal id or the public address, since this makes it easier for the SDK to find the key, if only the address is known.
 *   - d_token_t* keys      : (kms_create_key_attributes) the args describing the key to be updated.
 *   - d_token_t* signature : (kms_signature) signatures for policy challenge
 * Returns:
 *   - d_token_t* : (kms_key) the updated key
 */
#define TRY_CALL_KMS_UPDATE_KEY(ctx, res, id, keys, signature)                                           \
  {                                                                                                      \
    char*      jpayload = sprintx("\"%S\",%j,%j", (char*)id, (d_token_t*) keys, (d_token_t*) signature); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_KMS_UPDATE_KEY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
  }
#define FN_KMS_UPDATE_KEY "kms_update_key"

/**
 * deletes a new user. This is only available for users with the permission admin_key
 *
 *
 *
 * Parameters:
 *
 *   - char*      id        : (string) the internal id or the public address, since this makes it easier for the SDK to find the key, if only the address is known.
 *   - d_token_t* signature : (kms_signature) signatures for policy challenge
 * Returns:
 *   - d_token_t* : (kms_key) the key for the authenticated user
 */
#define TRY_CALL_KMS_DELETE_KEY(ctx, res, id, signature)                                                 \
  {                                                                                                      \
    char*      jpayload = sprintx("\"%S\",%j", (char*)id, (d_token_t*) signature);                       \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_KMS_DELETE_KEY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
  }
#define FN_KMS_DELETE_KEY "kms_delete_key"

/**
 * deletes a new user. This is only available for users with the permission admin_key
 *
 *
 *
 * Parameters:
 *
 *   - char*      id      : (string) the internal id or the public address, since this makes it easier for the SDK to find the key, if only the address is known.
 *   - d_token_t* payload : (kms_sign_payload) the payload to sign
 * Returns:
 *   - d_token_t* : (kms_signature) the signed message
 */
#define TRY_CALL_KMS_SIGN(ctx, res, id, payload)                                                   \
  {                                                                                                \
    char*      jpayload = sprintx("\"%S\",%j", (char*)id, (d_token_t*) payload);                   \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_KMS_SIGN, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                               \
    if (r) return r;                                                                               \
  }
#define FN_KMS_SIGN "kms_sign"

/**
 * decrypts data with a specific key after processing the policies
 *
 *
 *
 * Parameters:
 *
 *   - char*      id      : (string) the internal id or the public address, since this makes it easier for the SDK to find the key, if only the address is known.
 *   - d_token_t* payload : (kms_decrypt_payload) the payload to decrypt
 * Returns:
 *   - char* : (string) the decrypted data as hex
 */
#define TRY_CALL_KMS_DECRYPT(ctx, _res, id, payload)                                                  \
  {                                                                                                   \
    d_token_t* res;                                                                                   \
    char*      jpayload = sprintx("\"%S\",%j", (char*)id, (d_token_t*) payload);                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_KMS_DECRYPT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                  \
    if (r) return r;                                                                                  \
    _res = d_string(res);                                                                             \
  }
#define FN_KMS_DECRYPT "kms_decrypt"

/**
 * encrypts data with a specific key after processing the policies.
 *
 *
 *
 * Parameters:
 *
 *   - char*      id      : (string) the internal id or the public address, since this makes it easier for the SDK to find the key, if only the address is known.
 *   - d_token_t* payload : (kms_decrypt_payload) the payload to decrypt
 * Returns:
 *   - char* : (string) the encrypted data as hex
 */
#define TRY_CALL_KMS_ENCRYPT(ctx, _res, id, payload)                                                  \
  {                                                                                                   \
    d_token_t* res;                                                                                   \
    char*      jpayload = sprintx("\"%S\",%j", (char*)id, (d_token_t*) payload);                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_KMS_ENCRYPT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                  \
    if (r) return r;                                                                                  \
    _res = d_string(res);                                                                             \
  }
#define FN_KMS_ENCRYPT "kms_encrypt"

/**
 * fetches and verifies the nodeList from a node
 *
 *
 * Parameters:
 *
 *   - bytes_t    limit     : (int) if the number is defined and >0 this method will return a partial nodeList limited to the given number.
 *   - bytes_t    seed      : (bytes32) this 32byte hex integer is used to calculate the indexes of the partial nodeList. It is expected to be a random value choosen by the client in order to make the result deterministic.
 *   - d_token_t* addresses : (address) a optional array of addresses of signers the nodeList must include.
 * Returns:
 *   - d_token_t* : ([object Object]) the current nodelist
 */
#define TRY_CALL_IN3_NODELIST(ctx, res, limit, seed, addresses)                                                 \
  {                                                                                                             \
    char*      jpayload = sprintx("\"%B\",\"%B\",%j", (bytes_t) limit, (bytes_t) seed, (d_token_t*) addresses); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_NODELIST, jpayload, NULL, &res, NULL);          \
    _free(jpayload);                                                                                            \
    if (r) return r;                                                                                            \
  }
#define FN_IN3_NODELIST "in3_nodeList"

/**
 * requests a signed blockhash from the node.
 * In most cases these requests will come from other nodes, because the client simply adds the addresses of the requested signers
 * and the processising nodes will then aquire the signatures with this method from the other nodes.
 *
 * Since each node has a risk of signing a wrong blockhash and getting convicted and losing its deposit,
 * per default nodes will and should not sign blockHash of the last `minBlockHeight` (default: 6) blocks!
 *
 *
 *
 * Parameters:
 *
 *   - d_token_t* blocks : ([object Object]) array of requested blocks.
 * Returns:
 *   - d_token_t* : ([object Object]) the Array with signatures of all the requires blocks.
 */
#define TRY_CALL_IN3_SIGN(ctx, res, blocks)                                                        \
  {                                                                                                \
    char*      jpayload = sprintx("%j", (d_token_t*) blocks);                                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_SIGN, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                               \
    if (r) return r;                                                                               \
  }
#define FN_IN3_SIGN "in3_sign"

/**
 * Returns whitelisted in3-nodes addresses. The whitelist addressed are accquired from whitelist contract that user can specify in request params.
 *
 *
 * Parameters:
 *
 *   - uint8_t* address : (address) address of whitelist contract
 * Returns:
 *   - d_token_t* : ([object Object]) the whitelisted addresses
 */
#define TRY_CALL_IN3_WHITELIST(ctx, res, address)                                                       \
  {                                                                                                     \
    char*      jpayload = sprintx("\"%B\"", bytes(address, 20));                                        \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_WHITELIST, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                    \
    if (r) return r;                                                                                    \
  }
#define FN_IN3_WHITELIST "in3_whitelist"

/**
 * Generates 32 random bytes.
 * If /dev/urandom is available it will be used and should generate a secure random number.
 * If not the number should not be considered sceure or used in production.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t seed : (bytes) the seed. If given the result will be deterministic.
 * Returns:
 *   - bytes_t : (bytes32) the 32byte random data
 */
#define TRY_CALL_IN3_CREATEKEY(ctx, _res, seed)                                                         \
  {                                                                                                     \
    d_token_t* res;                                                                                     \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) seed);                                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_CREATEKEY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                    \
    if (r) return r;                                                                                    \
    _res = d_bytes(res);                                                                                \
  }
#define FN_IN3_CREATEKEY "in3_createKey"

/**
 * Generates 32 byte private key based on BIP 32.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t seed  : (bytes) the seed. it mus be at least 16 bytes long
 *   - char*   curve : (string) the name of the curve. should be one of `secp256k1`,`secp256k1-decred`,`secp256k1-groestl`,`secp256k1-smart`,`nist256p1`,`ed25519`,`ed25519 cardano seed`,`ed25519-sha3`,`curve25519`,`ed25519-keccak`
 *   - char*   path  : (string) the derivation path as specified in BIP32
 * Returns:
 *   - bytes_t : (bytes32) theprivate key
 */
#define TRY_CALL_IN3_BIP32(ctx, _res, seed, curve, path)                                              \
  {                                                                                                   \
    d_token_t* res;                                                                                   \
    char*      jpayload = sprintx("\"%B\",\"%S\",\"%S\"", (bytes_t) seed, (char*)curve, (char*)path); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_BIP32, jpayload, NULL, &res, NULL);   \
    _free(jpayload);                                                                                  \
    if (r) return r;                                                                                  \
    _res = d_bytes(res);                                                                              \
  }
#define FN_IN3_BIP32 "in3_bip32"

/**
 * generates a mnemonic based on bip39
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t seed : (bytes) the seed. if a seed is passed, this seed will be used to generate it, making it deterministic.
 * Returns:
 *   - char* : (string) a list of words based on bip39
 */
#define TRY_CALL_IN3_BIP39_CREATE(ctx, _res, seed)                                                         \
  {                                                                                                        \
    d_token_t* res;                                                                                        \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) seed);                                               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_BIP39_CREATE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                       \
    if (r) return r;                                                                                       \
    _res = d_string(res);                                                                                  \
  }
#define FN_IN3_BIP39_CREATE "in3_bip39_create"

/**
 * decodes a mnemonic and returns the seed as 64 bytes.
 *
 *
 *
 * Parameters:
 *
 *   - char* mnemonic   : (string) the mnemonic
 *   - char* passphrase : (string) the passphrase
 * Returns:
 *   - bytes_t : (bytes) the resulting seed
 */
#define TRY_CALL_IN3_BIP39_DECODE(ctx, _res, mnemonic, passphrase)                                         \
  {                                                                                                        \
    d_token_t* res;                                                                                        \
    char*      jpayload = sprintx("\"%S\",\"%S\"", (char*)mnemonic, (char*)passphrase);                    \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_BIP39_DECODE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                       \
    if (r) return r;                                                                                       \
    _res = d_bytes(res);                                                                                   \
  }
#define FN_IN3_BIP39_DECODE "in3_bip39_decode"

/**
 * Generates the public key from a private key for ed25519.
 *
 *
 * Parameters:
 *
 *   - bytes_t pk : (bytes32) the private key
 * Returns:
 *   - bytes_t : (bytes32) the 32byte public key
 */
#define TRY_CALL_IN3_ED25519_PK2PUB(ctx, _res, pk)                                                           \
  {                                                                                                          \
    d_token_t* res;                                                                                          \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) pk);                                                   \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_ED25519_PK2PUB, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
    _res = d_bytes(res);                                                                                     \
  }
#define FN_IN3_ED25519_PK2PUB "in3_ed25519_pk2pub"

/**
 * signs the message with for ed25519.
 *
 *
 * Parameters:
 *
 *   - bytes_t message : (bytes) the message to sign
 *   - bytes_t pk      : (bytes32) the private key
 * Returns:
 *   - bytes_t : (bytes) the 64byte signature
 */
#define TRY_CALL_IN3_ED25519_SIGN(ctx, _res, message, pk)                                                  \
  {                                                                                                        \
    d_token_t* res;                                                                                        \
    char*      jpayload = sprintx("\"%B\",\"%B\"", (bytes_t) message, (bytes_t) pk);                       \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_ED25519_SIGN, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                       \
    if (r) return r;                                                                                       \
    _res = d_bytes(res);                                                                                   \
  }
#define FN_IN3_ED25519_SIGN "in3_ed25519_sign"

/**
 * verifies the signature based on ed25519.
 *
 *
 * Parameters:
 *
 *   - bytes_t message   : (bytes) the message which was signed
 *   - bytes_t signature : (bytes) the 64 byte signature
 *   - bytes_t pubkey    : (bytes32) the 32 byte public key, whic is expected
 * Returns:
 *   - bool : (bool) true, if could be successfully verified.
 */
#define TRY_CALL_IN3_ED25519_VERIFY(ctx, _res, message, signature, pubkey)                                           \
  {                                                                                                                  \
    d_token_t* res;                                                                                                  \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\"", (bytes_t) message, (bytes_t) signature, (bytes_t) pubkey); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_ED25519_VERIFY, jpayload, NULL, &res, NULL);         \
    _free(jpayload);                                                                                                 \
    if (r) return r;                                                                                                 \
    _res = d_int(res);                                                                                               \
  }
#define FN_IN3_ED25519_VERIFY "in3_ed25519_verify"

/**
 * converts cyrptographic data based on the curve and type into a different form.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t data : (bytes) the data to convert. The length and kind of data depends on the conversion type.
 *   - char*   type : (string) the conversion type.
 *                    This Type may be prefixed with curvetype to be used (`ecdsa_` or `eddsa_`) , like `eddsa_pub32`.
 *
 *                    The following types are supported:
 *                    - pub64 : converts a private key (32 bytes) to a public key (64 bytes)
 *                    - pub32 : converts a private key (32 bytes) to a public key (32 bytes)
 *                    - sig_der : converts a signature (65 bytes) to a DER-encoded signature
 *                    - pub_der : converts a public key (32 or 64 bytes) to a DER-encoded pubkey
 *
 * Returns:
 *   - bytes_t : (bytes) the converted bytes.
 */
#define TRY_CALL_IN3_CRYPTO_CONVERT(ctx, _res, data, type)                                                   \
  {                                                                                                          \
    d_token_t* res;                                                                                          \
    char*      jpayload = sprintx("\"%B\",\"%S\"", (bytes_t) data, (char*)type);                             \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_CRYPTO_CONVERT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
    _res = d_bytes(res);                                                                                     \
  }
#define FN_IN3_CRYPTO_CONVERT "in3_crypto_convert"

/**
 * extracts the address from a private key.
 *
 *
 * Parameters:
 *
 *   - bytes_t pk : (bytes32) the 32 bytes private key as hex.
 * Returns:
 *   - bytes_t : (bytes) the address
 */
#define TRY_CALL_IN3_PK2ADDRESS(ctx, _res, pk)                                                           \
  {                                                                                                      \
    d_token_t* res;                                                                                      \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) pk);                                               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_PK2ADDRESS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
    _res = d_bytes(res);                                                                                 \
  }
#define FN_IN3_PK2ADDRESS "in3_pk2address"

/**
 * extracts the public key from a private key.
 *
 *
 * Parameters:
 *
 *   - bytes_t pk : (bytes32) the 32 bytes private key as hex.
 * Returns:
 *   - bytes_t : (bytes) the public key as 64 bytes
 */
#define TRY_CALL_IN3_PK2PUBLIC(ctx, _res, pk)                                                           \
  {                                                                                                     \
    d_token_t* res;                                                                                     \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) pk);                                              \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_PK2PUBLIC, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                    \
    if (r) return r;                                                                                    \
    _res = d_bytes(res);                                                                                \
  }
#define FN_IN3_PK2PUBLIC "in3_pk2public"

/**
 * extracts the public key and address from signature.
 *
 *
 * Parameters:
 *
 *   - char*   msg     : (string) the message the signature is based on.
 *   - bytes_t sig     : (bytes) the 65 bytes signature as hex.
 *   - char*   sigtype : (string) the type of the signature data : `eth_sign` (use the prefix and hash it), `raw` (hash the raw data), `hash` (use the already hashed data). Default: `raw`
 * Returns:
 *   - d_token_t* : ([object Object]) the extracted public key and address
 */
#define TRY_CALL_IN3_ECRECOVER(ctx, res, msg, sig, sigtype)                                             \
  {                                                                                                     \
    char*      jpayload = sprintx("\"%S\",\"%B\",\"%S\"", (char*)msg, (bytes_t) sig, (char*)sigtype);   \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_ECRECOVER, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                    \
    if (r) return r;                                                                                    \
  }
#define FN_IN3_ECRECOVER "in3_ecrecover"

/**
 * prepares a Transaction by filling the unspecified values and returens the unsigned raw Transaction.
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx : (eth_transaction) the tx-object, which is the same as specified in [eth_sendTransaction](https://eth.wiki/json-rpc/API#eth_sendTransaction).
 * Returns:
 *   - bytes_t : (bytes) the unsigned raw transaction as hex.
 */
#define TRY_CALL_IN3_PREPARETX(ctx, _res, tx)                                                           \
  {                                                                                                     \
    d_token_t* res;                                                                                     \
    char*      jpayload = sprintx("%j", (d_token_t*) tx);                                               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_PREPARETX, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                    \
    if (r) return r;                                                                                    \
    _res = d_bytes(res);                                                                                \
  }
#define FN_IN3_PREPARETX "in3_prepareTx"

/**
 * signs the given raw Tx (as prepared by in3_prepareTx ). The resulting data can be used in `eth_sendRawTransaction` to publish and broadcast the transaction.
 *
 *
 * Parameters:
 *
 *   - char*    tx   : (string) the raw unsigned transactiondata
 *   - uint8_t* from : (address) the account to sign
 * Returns:
 *   - bytes_t : (bytes) the raw transaction with signature.
 */
#define TRY_CALL_IN3_SIGNTX(ctx, _res, tx, from)                                                     \
  {                                                                                                  \
    d_token_t* res;                                                                                  \
    char*      jpayload = sprintx("\"%S\",\"%B\"", (char*)tx, bytes(from, 20));                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_SIGNTX, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                 \
    if (r) return r;                                                                                 \
    _res = d_bytes(res);                                                                             \
  }
#define FN_IN3_SIGNTX "in3_signTx"

/**
 * signs the given data.
 *
 *
 * Parameters:
 *
 *   - char*   msg     : (string) the message to sign.
 *   - bytes_t account : (bytes) the account to sign if the account is a bytes32 it will be used as private key
 *   - char*   msgType : (string) the type of the signature data : `eth_sign` (use the prefix and hash it), `raw` (hash the raw data), `hash` (use the already hashed data)
 * Returns:
 *   - d_token_t* : ([object Object]) the signature
 */
#define TRY_CALL_IN3_SIGNDATA(ctx, res, msg, account, msgType)                                            \
  {                                                                                                       \
    char*      jpayload = sprintx("\"%S\",\"%B\",\"%S\"", (char*)msg, (bytes_t) account, (char*)msgType); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_SIGNDATA, jpayload, NULL, &res, NULL);    \
    _free(jpayload);                                                                                      \
    if (r) return r;                                                                                      \
  }
#define FN_IN3_SIGNDATA "in3_signData"

/**
 * decrypts a JSON Keystore file as defined in the [Web3 Secret Storage Definition](https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition). The result is the raw private key.
 *
 *
 * Parameters:
 *
 *   - d_token_t* key        : (keyparams) the keyparams
 *   - char*      passphrase : (string) the password to decrypt it.
 * Returns:
 *   - bytes_t : (bytes32) a raw private key (32 bytes)
 */
#define TRY_CALL_IN3_DECRYPTKEY(ctx, _res, key, passphrase)                                              \
  {                                                                                                      \
    d_token_t* res;                                                                                      \
    char*      jpayload = sprintx("%j,\"%S\"", (d_token_t*) key, (char*)passphrase);                     \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_DECRYPTKEY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
    _res = d_bytes(res);                                                                                 \
  }
#define FN_IN3_DECRYPTKEY "in3_decryptKey"

/**
 * The sign method calculates an Ethereum specific signature with:
 *
 * ```js
 * sign(keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))).
 * ```
 *
 * By adding a prefix to the message makes the calculated signature recognisable as an Ethereum specific signature. This prevents misuse where a malicious DApp can sign arbitrary data (e.g. transaction) and use the signature to impersonate the victim.
 *
 * For the address to sign a signer must be registered.
 *
 *
 *
 * Parameters:
 *
 *   - uint8_t* account : (address) the account to sign with
 *   - bytes_t  message : (bytes) the message to sign
 * Returns:
 *   - bytes_t : (bytes) the signature (65 bytes) for the given message.
 */
#define TRY_CALL_ETH_SIGN(ctx, _res, account, message)                                             \
  {                                                                                                \
    d_token_t* res;                                                                                \
    char*      jpayload = sprintx("\"%B\",\"%B\"", bytes(account, 20), (bytes_t) message);         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_SIGN, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                               \
    if (r) return r;                                                                               \
    _res = d_bytes(res);                                                                           \
  }
#define FN_ETH_SIGN "eth_sign"

/**
 * Signs a transaction that can be submitted to the network at a later time using with eth_sendRawTransaction.
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx : (eth_transaction) transaction to sign
 * Returns:
 *   - bytes_t : (bytes) the raw signed transaction
 */
#define TRY_CALL_ETH_SIGNTRANSACTION(ctx, _res, tx)                                                           \
  {                                                                                                           \
    d_token_t* res;                                                                                           \
    char*      jpayload = sprintx("%j", (d_token_t*) tx);                                                     \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_SIGNTRANSACTION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
    _res = d_bytes(res);                                                                                      \
  }
#define FN_ETH_SIGNTRANSACTION "eth_signTransaction"

/**
 * returns the internal transactions send during execution of the tx. Currently this only works with geth with activated `debug` module (supporting `debug_traceTransaction` ). Also when running a pruned node, the state of transaction is only available for limited time ( mostly 5 min)
 *
 *
 * Parameters:
 *
 *   - bytes_t tx_hash : (bytes32) the transactionhash
 * Returns:
 *   - d_token_t* : (eth_internal_tx) an array of internal transactions
 */
#define TRY_CALL_IN3_GET_INTERNAL_TX(ctx, res, tx_hash)                                                       \
  {                                                                                                           \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) tx_hash);                                               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_GET_INTERNAL_TX, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_IN3_GET_INTERNAL_TX "in3_get_internal_tx"

/**
 * adds a raw private key as signer, which allows signing transactions.
 *
 *
 * Parameters:
 *
 *   - bytes_t pk    : (bytes32) the 32byte long private key as hex string.
 *   - char*   curve : (string) the curve of the key.
 * Returns:
 *   - bytes_t : (bytes) the unique identifier for the sdk of given key.
 */
#define TRY_CALL_IN3_ADDRAWKEY(ctx, _res, pk, curve)                                                    \
  {                                                                                                     \
    d_token_t* res;                                                                                     \
    char*      jpayload = sprintx("\"%B\",\"%S\"", (bytes_t) pk, (char*)curve);                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_ADDRAWKEY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                    \
    if (r) return r;                                                                                    \
    _res = d_bytes(res);                                                                                \
  }
#define FN_IN3_ADDRAWKEY "in3_addRawKey"

/**
 * decrypts a JSON Keystore file as defined in the [Web3 Secret Storage Definition](https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition) and adds it as signer.
 *
 *
 * Parameters:
 *
 *   - d_token_t* key        : (keyparams) the keyparams
 *   - char*      passphrase : (string) the password to decrypt it.
 * Returns:
 *   - uint8_t* : (address) the added address
 */
#define TRY_CALL_IN3_ADDJSONKEY(ctx, _res, key, passphrase)                                              \
  {                                                                                                      \
    d_token_t* res;                                                                                      \
    char*      jpayload = sprintx("%j,\"%S\"", (d_token_t*) key, (char*)passphrase);                     \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_ADDJSONKEY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
    _res = d_bytes(res).data;                                                                            \
  }
#define FN_IN3_ADDJSONKEY "in3_addJsonKey"

/**
 * adds a signer from a mnemomic phrase
 *
 *
 * Parameters:
 *
 *   - char*      mnemomic   : (string) the mnemomic phrase
 *   - char*      passphrase : (string) the password to decrypt it or null.
 *   - d_token_t* derivation : (string) the BIP32 derivation-path
 *   - char*      curve      : (string) the name of the curve. should be one of `secp256k1`,`secp256k1-decred`,`secp256k1-groestl`,`secp256k1-smart`,`nist256p1`,`ed25519`,`ed25519 cardano seed`,`ed25519-sha3`,`curve25519`,`ed25519-keccak`
 * Returns:
 *   - d_token_t* : (address) the added address
 */
#define TRY_CALL_IN3_ADDMNEMONIC(ctx, res, mnemomic, passphrase, derivation, curve)                                                      \
  {                                                                                                                                      \
    char*      jpayload = sprintx("\"%S\",\"%S\",%j,\"%S\"", (char*)mnemomic, (char*)passphrase, (d_token_t*) derivation, (char*)curve); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_ADDMNEMONIC, jpayload, NULL, &res, NULL);                                \
    _free(jpayload);                                                                                                                     \
    if (r) return r;                                                                                                                     \
  }
#define FN_IN3_ADDMNEMONIC "in3_addMnemonic"

/**
 * returns a array of signer_ids the client is able to sign with.
 *
 * In order to add keys, you can use [in3_addRawKey](#in3-addrawkey) or configure them in the config. The result also contains the signer_ids of any signer signer-supporting the `PLGN_ACT_SIGN_ACCOUNT` action.
 *
 *
 * Returns:
 *   - d_token_t* : (address) the array of signer_ids of all registered signers.
 */
#define TRY_CALL_SIGNER_IDS(ctx, res)                                                          \
  {                                                                                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SIGNER_IDS, "", NULL, &res, NULL); \
    if (r) return r;                                                                           \
  }
#define FN_SIGNER_IDS "signer_ids"

/**
 * alias to signer_ids
 *
 *
 * Returns:
 *   - d_token_t* : (address) the array of signer_ids of all registered signers.
 */
#define TRY_CALL_ETH_ACCOUNTS(ctx, res)                                                          \
  {                                                                                              \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ETH_ACCOUNTS, "", NULL, &res, NULL); \
    if (r) return r;                                                                             \
  }
#define FN_ETH_ACCOUNTS "eth_accounts"

/**
 * get the current account uuid
 *
 * Returns:
 *   - d_token_t* : ([object Object]) the result
 */
#define TRY_CALL_SSI_GET_ACCOUNT_DATA(ctx, res)                                                          \
  {                                                                                                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_ACCOUNT_DATA, "", NULL, &res, NULL); \
    if (r) return r;                                                                                     \
  }
#define FN_SSI_GET_ACCOUNT_DATA "ssi_get_account_data"

/**
 * creates an account for the given email address
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_account) the data object
 * Returns:
 *   - d_token_t* : (ssi_account_result) successful operation
 */
#define TRY_CALL_SSI_CREATE_ACCOUNT(ctx, res, data)                                                          \
  {                                                                                                          \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CREATE_ACCOUNT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
  }
#define FN_SSI_CREATE_ACCOUNT "ssi_create_account"

/**
 * update an account with passed values
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_account) the data object
 * Returns:
 *   - d_token_t* : (ssi_account_result) successful operation
 */
#define TRY_CALL_SSI_UPDATE_ACCOUNT(ctx, res, data)                                                          \
  {                                                                                                          \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_UPDATE_ACCOUNT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
  }
#define FN_SSI_UPDATE_ACCOUNT "ssi_update_account"

/**
 * verify an account for the given email/phone
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_account_verify) the data object
 * Returns:
 *   - d_token_t* : (ssi_account_result) Successful operation
 */
#define TRY_CALL_SSI_ACCOUNT_VERIFY(ctx, res, data)                                                          \
  {                                                                                                          \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_ACCOUNT_VERIFY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
  }
#define FN_SSI_ACCOUNT_VERIFY "ssi_account_verify"

/**
 * gets an account with the given uuid
 *
 *
 * Parameters:
 *
 *   - char* uuid : (string) uuid of the account to get
 * Returns:
 *   - d_token_t* : (ssi_account_get_result) successful operation
 */
#define TRY_CALL_SSI_GET_ACCOUNT(ctx, res, uuid)                                                          \
  {                                                                                                       \
    char*      jpayload = sprintx("\"%S\"", (char*)uuid);                                                 \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_ACCOUNT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                      \
    if (r) return r;                                                                                      \
  }
#define FN_SSI_GET_ACCOUNT "ssi_get_account"

/**
 * updates an account with the given uuid
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_account) the data object
 *   - char*      uuid : (string) uuid of the account to update
 * Returns:
 *   - d_token_t* : (ssi_account_result) successful operation
 */
#define TRY_CALL_SSI_UPDATE_ACCOUNT_BY_UUID(ctx, res, data, uuid)                                                    \
  {                                                                                                                  \
    char*      jpayload = sprintx("%j,\"%S\"", (d_token_t*) data, (char*)uuid);                                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_UPDATE_ACCOUNT_BY_UUID, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                 \
    if (r) return r;                                                                                                 \
  }
#define FN_SSI_UPDATE_ACCOUNT_BY_UUID "ssi_update_account_by_uuid"

/**
 * Enable checking the existence of a `username`, so the UI can get a clue early if a specific username if already taken.
 *
 *
 * Parameters:
 *
 *   - char* username : (string) The unique `username` to check its existence
 * Returns:
 *   - d_token_t* : (ssi_check_username_result) the username has been checked
 */
#define TRY_CALL_SSI_CHECK_USERNAME(ctx, res, username)                                                      \
  {                                                                                                          \
    char*      jpayload = sprintx("\"%S\"", (char*)username);                                                \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CHECK_USERNAME, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
  }
#define FN_SSI_CHECK_USERNAME "ssi_check_username"

/**
 * register a new user for the given username and password
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_register) the data object
 * Returns:
 *   - d_token_t* : (ssi_register_result) successful operation
 */
#define TRY_CALL_SSI_REGISTER(ctx, res, data)                                                          \
  {                                                                                                    \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_REGISTER, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                   \
    if (r) return r;                                                                                   \
  }
#define FN_SSI_REGISTER "ssi_register"

/**
 * reset the password for a registered user
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_reset_password) the data object
 * Returns:
 *   - char* : (string) successful operation
 */
#define TRY_CALL_SSI_RESET_PASSWORD(ctx, _res, data)                                                         \
  {                                                                                                          \
    d_token_t* res;                                                                                          \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_RESET_PASSWORD, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
    _res = d_string(res);                                                                                    \
  }
#define FN_SSI_RESET_PASSWORD "ssi_reset_password"

/**
 * adds an asset for the specified principal. If blobData is parsed then the data will be saved to the blobstore and Uri will be added to the referenceUri field.
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_asset) the data object
 * Returns:
 *   - d_token_t* : (ssi_asset_result) successful operation
 */
#define TRY_CALL_SSI_CREATE_ASSET(ctx, res, data)                                                          \
  {                                                                                                        \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                                \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CREATE_ASSET, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                       \
    if (r) return r;                                                                                       \
  }
#define FN_SSI_CREATE_ASSET "ssi_create_asset"

/**
 * retrieves the asset having the parsed uuid
 *
 *
 * Parameters:
 *
 *   - char*      uuid           : (string) uuid of the asset to get
 *   - char*      end_point_type : (string) pass "resolve" here, to resolve the data for the asset present in the blob store. If the file is not a stringified JSON, the reference url to that fille will be returned, otherwise a parsed json. If not passed then will return the asset.
 *   - d_token_t* relations      : (string) array of names of tables to which the asset has relation with
 * Returns:
 *   - d_token_t* : (ssi_asset_get_result) successful operation
 */
#define TRY_CALL_SSI_GET_ASSET_BY_END_POINT_TYPE(ctx, res, uuid, end_point_type, relations)                               \
  {                                                                                                                       \
    char*      jpayload = sprintx("\"%S\",\"%S\",%j", (char*)uuid, (char*)end_point_type, (d_token_t*) relations);        \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_ASSET_BY_END_POINT_TYPE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                      \
    if (r) return r;                                                                                                      \
  }
#define FN_SSI_GET_ASSET_BY_END_POINT_TYPE "ssi_get_asset_by_end_point_type"

/**
 * updates the asset for the provided uuid and belonging to the specified principal. If blobData is parsed then updates the blobstorage data using the pre-existing referenceUri. If no referenceUri exists then a new one is generated and updated.
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_asset) the data object
 *   - char*      uuid : (string) uuid of the asset to update
 * Returns:
 *   - d_token_t* : (ssi_asset_result) successful operation
 */
#define TRY_CALL_SSI_UPDATE_ASSET(ctx, res, data, uuid)                                                    \
  {                                                                                                        \
    char*      jpayload = sprintx("%j,\"%S\"", (d_token_t*) data, (char*)uuid);                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_UPDATE_ASSET, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                       \
    if (r) return r;                                                                                       \
  }
#define FN_SSI_UPDATE_ASSET "ssi_update_asset"

/**
 * deletes the asset having the parsed uuid and belonging to current principal
 *
 *
 * Parameters:
 *
 *   - char* uuid : (string) uuid of the asset to delete
 * Returns:
 *   - char* : (string) successful operation
 */
#define TRY_CALL_SSI_DELETE_ASSET(ctx, _res, uuid)                                                         \
  {                                                                                                        \
    d_token_t* res;                                                                                        \
    char*      jpayload = sprintx("\"%S\"", (char*)uuid);                                                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_DELETE_ASSET, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                       \
    if (r) return r;                                                                                       \
    _res = d_string(res);                                                                                  \
  }
#define FN_SSI_DELETE_ASSET "ssi_delete_asset"

/**
 * adds an assetData belonging to a certain asset
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_asset_data) the data object
 * Returns:
 *   - d_token_t* : (ssi_asset_data_result) successful operation
 */
#define TRY_CALL_SSI_CREATE_ASSET_DATA(ctx, res, data)                                                          \
  {                                                                                                             \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                                     \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CREATE_ASSET_DATA, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                            \
    if (r) return r;                                                                                            \
  }
#define FN_SSI_CREATE_ASSET_DATA "ssi_create_asset_data"

/**
 * Get all asset-data
 *   - results includes a `total` property that you can use to check if you need to page
 *   - `skip` to specify your entry offset (default is `0`)
 *   - `take` to adjust number of entries returned in request (default is `10`)
 *
 *
 *
 * Parameters:
 *
 *   - uint32_t   skip      : (uint32) skip this many results, used for paging in 'all' queries
 *   - uint32_t   take      : (uint32) take this many results, used for paging in 'all' queries
 *   - d_token_t* relations : (string) array of names of tables to which the assetData has relation with
 * Returns:
 *   - d_token_t* : (ssi_asset_data_get_result) successful operation
 */
#define TRY_CALL_SSI_GET_ASSET_DATAS(ctx, res, skip, take, relations)                                          \
  {                                                                                                            \
    char*      jpayload = sprintx("\"%u\",\"%u\",%j", (uint32_t)skip, (uint32_t)take, (d_token_t*) relations); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_ASSET_DATAS, jpayload, NULL, &res, NULL);  \
    _free(jpayload);                                                                                           \
    if (r) return r;                                                                                           \
  }
#define FN_SSI_GET_ASSET_DATAS "ssi_get_asset_datas"

/**
 * retrieves the asset data having given uuid and belonging to current principal
 *
 *
 * Parameters:
 *
 *   - char*      uuid      : (string) uuid of the required asset-data
 *   - d_token_t* relations : (string) array of names of tables to which the assetData has relation with
 * Returns:
 *   - d_token_t* : (ssi_asset_data_result) successful operation
 */
#define TRY_CALL_SSI_GET_ASSET_DATA(ctx, res, uuid, relations)                                               \
  {                                                                                                          \
    char*      jpayload = sprintx("\"%S\",%j", (char*)uuid, (d_token_t*) relations);                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_ASSET_DATA, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
  }
#define FN_SSI_GET_ASSET_DATA "ssi_get_asset_data"

/**
 * updates an asset data with given uuid and belonging to current principal
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_asset_data_data) the data object
 *   - char*      uuid : (string) the [object Object]
 * Returns:
 *   - d_token_t* : (ssi_asset_data_result) successful operation
 */
#define TRY_CALL_SSI_UPDATE_ASSET_DATA(ctx, res, data, uuid)                                                    \
  {                                                                                                             \
    char*      jpayload = sprintx("%j,\"%S\"", (d_token_t*) data, (char*)uuid);                                 \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_UPDATE_ASSET_DATA, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                            \
    if (r) return r;                                                                                            \
  }
#define FN_SSI_UPDATE_ASSET_DATA "ssi_update_asset_data"

/**
 * deletes the asset data having given uuid and belonging to current principal
 *
 *
 * Parameters:
 *
 *   - char* uuid : (string) the [object Object]
 * Returns:
 *   - char* : (string) successful operation
 */
#define TRY_CALL_SSI_DELETE_ASSET_DATA(ctx, _res, uuid)                                                         \
  {                                                                                                             \
    d_token_t* res;                                                                                             \
    char*      jpayload = sprintx("\"%S\"", (char*)uuid);                                                       \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_DELETE_ASSET_DATA, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                            \
    if (r) return r;                                                                                            \
    _res = d_string(res);                                                                                       \
  }
#define FN_SSI_DELETE_ASSET_DATA "ssi_delete_asset_data"

/**
 * adds a contact for a specific principal and sends an email invitation to the partner
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_contact) the data object
 * Returns:
 *   - d_token_t* : (ssi_contact_result) successful operation
 */
#define TRY_CALL_SSI_CREATE_CONTACT(ctx, res, data)                                                          \
  {                                                                                                          \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CREATE_CONTACT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
  }
#define FN_SSI_CREATE_CONTACT "ssi_create_contact"

/**
 * Get all contacts
 *   - results includes a `total` property that you can use to check if you need to page
 *   - `skip` to specify your entry offset (default is `0`)
 *   - `take` to adjust number of entries returned in request (default is `10`)
 *
 *
 *
 * Parameters:
 *
 *   - char*    filter : (string) only return contacts where display name containing this filter input
 *   - uint32_t skip   : (uint32) skip this many results, used for paging in 'all' queries
 *   - uint32_t take   : (uint32) take this many results, used for paging in 'all' queries
 * Returns:
 *   - d_token_t* : (ssi_result) successful operation
 */
#define TRY_CALL_SSI_GET_CONTACTS(ctx, res, filter, skip, take)                                            \
  {                                                                                                        \
    char*      jpayload = sprintx("\"%S\",\"%u\",\"%u\"", (char*)filter, (uint32_t)skip, (uint32_t)take);  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_CONTACTS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                       \
    if (r) return r;                                                                                       \
  }
#define FN_SSI_GET_CONTACTS "ssi_get_contacts"

/**
 * Gets contact by either uuid, did or email.
 * If available result also includes credential data shared by the given contact as `sharedData`.
 *
 *
 *
 * Parameters:
 *
 *   - char*    identifier : (string) retrieves the contact having the given identifier as uuid, did or email
 *   - uint32_t skip       : (uint32) skip this many results, used for paging in 'all' queries
 *   - uint32_t take       : (uint32) take this many results, used for paging in 'all' queries
 * Returns:
 *   - d_token_t* : (any) successful operation
 */
#define TRY_CALL_SSI_GET_CONTACT(ctx, res, identifier, skip, take)                                            \
  {                                                                                                           \
    char*      jpayload = sprintx("\"%S\",\"%u\",\"%u\"", (char*)identifier, (uint32_t)skip, (uint32_t)take); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_CONTACT, jpayload, NULL, &res, NULL);     \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_SSI_GET_CONTACT "ssi_get_contact"

/**
 * updates a contact for the specified principal
 *
 *
 * Parameters:
 *
 *   - d_token_t* data       : (ssi_contact_contact) the data object
 *   - char*      identifier : (string) updates the contact having the given uuid/did for the current principal
 * Returns:
 *   - d_token_t* : (ssi_contact_put_result) successful operation
 */
#define TRY_CALL_SSI_UPDATE_CONTACT(ctx, res, data, identifier)                                              \
  {                                                                                                          \
    char*      jpayload = sprintx("%j,\"%S\"", (d_token_t*) data, (char*)identifier);                        \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_UPDATE_CONTACT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
  }
#define FN_SSI_UPDATE_CONTACT "ssi_update_contact"

/**
 * Bulk import of contacts by adding and inviting them via email. However, only CSV is currently supported.
 *
 *
 * Parameters:
 *
 *   - char* data   : (string) the data object
 *   - char* format : (string) defines the file format for the import (currently only csv)
 * Returns:
 *   - d_token_t* : (ssi_contact_contact) successful operation
 */
#define TRY_CALL_SSI_CONTACT_IMPORT(ctx, res, data, format)                                                  \
  {                                                                                                          \
    char*      jpayload = sprintx("\"%S\",\"%S\"", (char*)data, (char*)format);                              \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CONTACT_IMPORT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
  }
#define FN_SSI_CONTACT_IMPORT "ssi_contact_import"

/**
 * Gets activity stream (actions) with given contact in either FROM or TO.
 *
 *
 * Parameters:
 *
 *   - char*    identifier : (string) contact as uuid, did or email
 *   - uint32_t skip       : (uint32) skip this many results, used for paging in 'all' queries
 *   - uint32_t take       : (uint32) take this many results, used for paging in 'all' queries
 * Returns:
 *   - d_token_t* : (ssi_result) successful operation
 */
#define TRY_CALL_SSI_CONTACT_GET_ACTIVITY_STREAMS(ctx, res, identifier, skip, take)                                        \
  {                                                                                                                        \
    char*      jpayload = sprintx("\"%S\",\"%u\",\"%u\"", (char*)identifier, (uint32_t)skip, (uint32_t)take);              \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CONTACT_GET_ACTIVITY_STREAMS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                       \
    if (r) return r;                                                                                                       \
  }
#define FN_SSI_CONTACT_GET_ACTIVITY_STREAMS "ssi_contact_get_activity_streams"

/**
 * allows an identity to self issue a credential using a specified credential template
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_credential) the data object
 * Returns:
 *   - d_token_t* : (ssi_asset_data_result) successful operation
 */
#define TRY_CALL_SSI_CREATE_CREDENTIAL(ctx, res, data)                                                          \
  {                                                                                                             \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                                     \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CREATE_CREDENTIAL, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                            \
    if (r) return r;                                                                                            \
  }
#define FN_SSI_CREATE_CREDENTIAL "ssi_create_credential"

/**
 * Gets credentials for current user. Can be used with out without filtering whereby behavior
 * changes slightly:
 *   - without filtering:
 *     - returns all credentials and results can be paged
 *   - results includes a `total` property that you can use to check if you need to page
 *   - `skip` to specify your entry offset (default is `0`)
 *   - `take` to adjust number of entries returned in request (default is `10`)
 *
 *
 *
 * Parameters:
 *
 *   - d_token_t* filter    : (ssi_filter) only return credentials with one of the given template names;
 *                            note also that format for filtered credentials differs slightly and
 *                            that filtering is not compatible with paging and relations
 *
 *   - uint32_t   take      : (uint32) for results without filter: take this many results, used for paging in 'all' queries,
 *                            for results with filter: return this many entries per template name
 *
 *   - uint32_t   skip      : (uint32) skip this many results, used for paging in 'all' queries,
 *                            only supported for requests without filter
 *
 *   - d_token_t* relations : (string) array of names of tables to which the credential has relations with,
 *                            only supported for requests without filter
 *
 * Returns:
 *   - d_token_t* : (any) successful operation
 */
#define TRY_CALL_SSI_GET_CREDENTIALS(ctx, res, filter, take, skip, relations)                                                          \
  {                                                                                                                                    \
    char*      jpayload = sprintx("%j,\"%u\",\"%u\",%j", (d_token_t*) filter, (uint32_t)take, (uint32_t)skip, (d_token_t*) relations); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_CREDENTIALS, jpayload, NULL, &res, NULL);                          \
    _free(jpayload);                                                                                                                   \
    if (r) return r;                                                                                                                   \
  }
#define FN_SSI_GET_CREDENTIALS "ssi_get_credentials"

/**
 * gets the credential for given uuid for current principal
 *
 *
 * Parameters:
 *
 *   - char*      uuid      : (string) uuid of a credential
 *   - d_token_t* relations : (string) array of names of tables to which the credential has relations with
 * Returns:
 *   - d_token_t* : (ssi_credential_result) successful operation
 */
#define TRY_CALL_SSI_GET_CREDENTIAL(ctx, res, uuid, relations)                                               \
  {                                                                                                          \
    char*      jpayload = sprintx("\"%S\",%j", (char*)uuid, (d_token_t*) relations);                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_CREDENTIAL, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
  }
#define FN_SSI_GET_CREDENTIAL "ssi_get_credential"

/**
 * updates a credential for given uuid for current principal
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_asset_data_data) the data object
 *   - char*      uuid : (string) uuid of credential to update
 * Returns:
 *   - d_token_t* : (ssi_credential_result) successful operation
 */
#define TRY_CALL_SSI_UPDATE_CREDENTIAL(ctx, res, data, uuid)                                                    \
  {                                                                                                             \
    char*      jpayload = sprintx("%j,\"%S\"", (d_token_t*) data, (char*)uuid);                                 \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_UPDATE_CREDENTIAL, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                            \
    if (r) return r;                                                                                            \
  }
#define FN_SSI_UPDATE_CREDENTIAL "ssi_update_credential"

/**
 * deletes the credential for given uuid for current principal
 *
 *
 * Parameters:
 *
 *   - char* uuid : (string) uuid of credential to delete
 * Returns:
 *   - char* : (string) successful operation
 */
#define TRY_CALL_SSI_DELETE_CREDENTIAL(ctx, _res, uuid)                                                         \
  {                                                                                                             \
    d_token_t* res;                                                                                             \
    char*      jpayload = sprintx("\"%S\"", (char*)uuid);                                                       \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_DELETE_CREDENTIAL, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                            \
    if (r) return r;                                                                                            \
    _res = d_string(res);                                                                                       \
  }
#define FN_SSI_DELETE_CREDENTIAL "ssi_delete_credential"

/**
 * marks a given credential as favorite for given identity
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_credential_favorite) the data object
 *   - char*      uuid : (string) uuid of credential to mark as favorite
 * Returns:
 *   - char* : (string) successful operation
 */
#define TRY_CALL_SSI_CREDENTIAL_CREATE_FAVORITE(ctx, _res, data, uuid)                                                   \
  {                                                                                                                      \
    d_token_t* res;                                                                                                      \
    char*      jpayload = sprintx("%j,\"%S\"", (d_token_t*) data, (char*)uuid);                                          \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CREDENTIAL_CREATE_FAVORITE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                     \
    if (r) return r;                                                                                                     \
    _res = d_string(res);                                                                                                \
  }
#define FN_SSI_CREDENTIAL_CREATE_FAVORITE "ssi_credential_create_favorite"

/**
 * removes a given credential from favorites of given identity
 *
 *
 * Parameters:
 *
 *   - char* uuid        : (string) uuid of credential to remove from favorites
 *   - char* identity_id : (string) uuid of identity to remove favorite for
 * Returns:
 *   - char* : (string) successful operation
 */
#define TRY_CALL_SSI_CREDENTIAL_DELETE_FAVORITE(ctx, _res, uuid, identity_id)                                            \
  {                                                                                                                      \
    d_token_t* res;                                                                                                      \
    char*      jpayload = sprintx("\"%S\",\"%S\"", (char*)uuid, (char*)identity_id);                                     \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CREDENTIAL_DELETE_FAVORITE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                     \
    if (r) return r;                                                                                                     \
    _res = d_string(res);                                                                                                \
  }
#define FN_SSI_CREDENTIAL_DELETE_FAVORITE "ssi_credential_delete_favorite"

/**
 * creates a new credential definition for the provided identity and based on given credential template
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_credential_definition) the data object
 * Returns:
 *   - d_token_t* : (ssi_credential_definition_result) successful operation
 */
#define TRY_CALL_SSI_CREATE_CREDENTIAL_DEFINITION(ctx, res, data)                                                          \
  {                                                                                                                        \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                                                \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CREATE_CREDENTIAL_DEFINITION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                       \
    if (r) return r;                                                                                                       \
  }
#define FN_SSI_CREATE_CREDENTIAL_DEFINITION "ssi_create_credential_definition"

/**
 * gets credential definition for the given uuid
 *
 *
 * Parameters:
 *
 *   - char* uuid : (string) uuid of the required credential definition
 * Returns:
 *   - d_token_t* : (ssi_credential_definition_result) successful operation
 */
#define TRY_CALL_SSI_GET_CREDENTIAL_DEFINITION(ctx, res, uuid)                                                          \
  {                                                                                                                     \
    char*      jpayload = sprintx("\"%S\"", (char*)uuid);                                                               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_CREDENTIAL_DEFINITION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                    \
    if (r) return r;                                                                                                    \
  }
#define FN_SSI_GET_CREDENTIAL_DEFINITION "ssi_get_credential_definition"

/**
 * deletes a credential definition
 *
 *
 * Parameters:
 *
 *   - char* uuid : (string) uuid of the credential definition to be deleted
 * Returns:
 *   - char* : (string) successful operation
 */
#define TRY_CALL_SSI_DELETE_CREDENTIAL_DEFINITION(ctx, _res, uuid)                                                         \
  {                                                                                                                        \
    d_token_t* res;                                                                                                        \
    char*      jpayload = sprintx("\"%S\"", (char*)uuid);                                                                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_DELETE_CREDENTIAL_DEFINITION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                       \
    if (r) return r;                                                                                                       \
    _res = d_string(res);                                                                                                  \
  }
#define FN_SSI_DELETE_CREDENTIAL_DEFINITION "ssi_delete_credential_definition"

/**
 * creates an empty identity
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_identity) the data object
 * Returns:
 *   - d_token_t* : (ssi_identity_result) successful operation
 */
#define TRY_CALL_SSI_CREATE_IDENTITY(ctx, res, data)                                                          \
  {                                                                                                           \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                                   \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CREATE_IDENTITY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_SSI_CREATE_IDENTITY "ssi_create_identity"

/**
 * Get all identities for a principal
 *   - results includes a `total` property that you can use to check if you need to page
 *   - `skip` to specify your entry offset (default is `0`)
 *   - `take` to adjust number of entries returned in request (default is `10`)
 *
 *
 *
 * Parameters:
 *
 *   - uint32_t skip : (uint32) skip this many results, used for paging in 'all' queries
 *   - uint32_t take : (uint32) take this many results, used for paging in 'all' queries
 * Returns:
 *   - d_token_t* : (ssi_result) successful operation
 */
#define TRY_CALL_SSI_GET_IDENTITIES(ctx, res, skip, take)                                                    \
  {                                                                                                          \
    char*      jpayload = sprintx("\"%u\",\"%u\"", (uint32_t)skip, (uint32_t)take);                          \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_IDENTITIES, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
  }
#define FN_SSI_GET_IDENTITIES "ssi_get_identities"

/**
 * Gets one identity depending on given `identifier`:
 *   - given a uuid / did of an identity: returns this identity
 *
 *
 *
 * Parameters:
 *
 *   - char* identifier : (string) did / uuid of the required identity
 * Returns:
 *   - d_token_t* : (ssi_identity_get_result) successful operation
 */
#define TRY_CALL_SSI_GET_IDENTITY(ctx, res, identifier)                                                    \
  {                                                                                                        \
    char*      jpayload = sprintx("\"%S\"", (char*)identifier);                                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_IDENTITY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                       \
    if (r) return r;                                                                                       \
  }
#define FN_SSI_GET_IDENTITY "ssi_get_identity"

/**
 * updates an identity
 *
 *
 * Parameters:
 *
 *   - d_token_t* data       : (ssi_identity_data) the data object
 *   - char*      identifier : (string) did / uuid of the identity to be updated
 * Returns:
 *   - d_token_t* : (ssi_identity_result) successful operation
 */
#define TRY_CALL_SSI_UPDATE_IDENTITY(ctx, res, data, identifier)                                              \
  {                                                                                                           \
    char*      jpayload = sprintx("%j,\"%S\"", (d_token_t*) data, (char*)identifier);                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_UPDATE_IDENTITY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_SSI_UPDATE_IDENTITY "ssi_update_identity"

/**
 * creates a new presentation
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_presentation) the data object
 * Returns:
 *   - d_token_t* : (ssi_presentation_result) successful operation
 */
#define TRY_CALL_SSI_CREATE_PRESENTATION(ctx, res, data)                                                          \
  {                                                                                                               \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                                       \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CREATE_PRESENTATION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                              \
    if (r) return r;                                                                                              \
  }
#define FN_SSI_CREATE_PRESENTATION "ssi_create_presentation"

/**
 * Get all presentations
 *   - results includes a `total` property that you can use to check if you need to page
 *   - `skip` to specify your entry offset (default is `0`)
 *   - `take` to adjust number of entries returned in request (default is `10`)
 *
 *
 *
 * Parameters:
 *
 *   - uint32_t skip : (uint32) skip this many results, used for paging in queries
 *   - uint32_t take : (uint32) take this many results, used for paging in queries
 * Returns:
 *   - d_token_t* : (ssi_asset_data_get_result) successful operation
 */
#define TRY_CALL_SSI_GET_PRESENTATIONS(ctx, res, skip, take)                                                    \
  {                                                                                                             \
    char*      jpayload = sprintx("\"%u\",\"%u\"", (uint32_t)skip, (uint32_t)take);                             \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_PRESENTATIONS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                            \
    if (r) return r;                                                                                            \
  }
#define FN_SSI_GET_PRESENTATIONS "ssi_get_presentations"

/**
 * Gets a presentations depending with given `uuid`:
 *   - `uuid` given as a `uuid` of a presentation: returns this presentation,
 *   - if `uuid` provided as `uuid` and `actionType` is `'verify'`: presentation will be verified instead of being returned
 *
 *
 *
 * Parameters:
 *
 *   - char* uuid : (string) uuid of a presentation
 *   - char* type : (string) type of a presentation
 * Returns:
 *   - d_token_t* : (ssi_presentation_get_result) successful operation
 */
#define TRY_CALL_SSI_GET_PRESENTATION(ctx, res, uuid, type)                                                    \
  {                                                                                                            \
    char*      jpayload = sprintx("\"%S\",\"%S\"", (char*)uuid, (char*)type);                                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_PRESENTATION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                           \
    if (r) return r;                                                                                           \
  }
#define FN_SSI_GET_PRESENTATION "ssi_get_presentation"

/**
 * creates a new proof request
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_proof_request) the data object
 * Returns:
 *   - d_token_t* : (ssi_presentation_result) successful operation
 */
#define TRY_CALL_SSI_CREATE_PROOF_REQUEST(ctx, res, data)                                                          \
  {                                                                                                                \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                                        \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CREATE_PROOF_REQUEST, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                               \
    if (r) return r;                                                                                               \
  }
#define FN_SSI_CREATE_PROOF_REQUEST "ssi_create_proof_request"

/**
 * Get all proof-requests
 *   - results includes a `total` property that you can use to check if you need to page
 *   - `skip` to specify your entry offset (default is `0`)
 *   - `take` to adjust number of entries returned in request (default is `10`)
 *
 *
 *
 * Parameters:
 *
 *   - uint32_t skip : (uint32) skip this many results, used for paging in 'all' queries
 *   - uint32_t take : (uint32) take this many results, used for paging in 'all' queries
 * Returns:
 *   - d_token_t* : (ssi_asset_data_get_result) successful operation
 */
#define TRY_CALL_SSI_GET_PROOF_REQUESTS(ctx, res, skip, take)                                                    \
  {                                                                                                              \
    char*      jpayload = sprintx("\"%u\",\"%u\"", (uint32_t)skip, (uint32_t)take);                              \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_PROOF_REQUESTS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                             \
    if (r) return r;                                                                                             \
  }
#define FN_SSI_GET_PROOF_REQUESTS "ssi_get_proof_requests"

/**
 * Gets a proof requests with given `uuid`. If `actionType` is `'verify'`, proof request will be verified instead of being returned.
 *
 *
 *
 * Parameters:
 *
 *   - char*    uuid : (string) uuid of a proof request or `'all'`
 *   - uint32_t skip : (uint32) skip this many results, used for paging in 'all' queries
 *   - uint32_t take : (uint32) take this many results, used for paging in 'all' queries
 * Returns:
 *   - d_token_t* : (ssi_credential_result) successful operation
 */
#define TRY_CALL_SSI_GET_PROOF_REQUEST(ctx, res, uuid, skip, take)                                              \
  {                                                                                                             \
    char*      jpayload = sprintx("\"%S\",\"%u\",\"%u\"", (char*)uuid, (uint32_t)skip, (uint32_t)take);         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_PROOF_REQUEST, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                            \
    if (r) return r;                                                                                            \
  }
#define FN_SSI_GET_PROOF_REQUEST "ssi_get_proof_request"

/**
 * creates a generic credential schema that can be used for cross company data exchange
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_schema) the data object
 * Returns:
 *   - d_token_t* : (ssi_schema_result) successful operation
 */
#define TRY_CALL_SSI_CREATE_SCHEMA(ctx, res, data)                                                          \
  {                                                                                                         \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                                 \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CREATE_SCHEMA, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                        \
    if (r) return r;                                                                                        \
  }
#define FN_SSI_CREATE_SCHEMA "ssi_create_schema"

/**
 * Get all schemas
 *   - results includes a `total` property that you can use to check if you need to page
 *   - `skip` to specify your entry offset (default is `0`)
 *   - `take` to adjust number of entries returned in request (default is `10`)
 *
 *
 *
 * Parameters:
 *
 *   - uint32_t skip : (uint32) skip this many results, used for paging in 'all' queries
 *   - uint32_t take : (uint32) take this many results, used for paging in 'all' queries
 * Returns:
 *   - d_token_t* : (ssi_result) successful operation
 */
#define TRY_CALL_SSI_GET_SCHEMAS(ctx, res, skip, take)                                                    \
  {                                                                                                       \
    char*      jpayload = sprintx("\"%u\",\"%u\"", (uint32_t)skip, (uint32_t)take);                       \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_SCHEMAS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                      \
    if (r) return r;                                                                                      \
  }
#define FN_SSI_GET_SCHEMAS "ssi_get_schemas"

/**
 * retrieves a generic credential schema that can be used for cross company data exchange
 *
 *
 * Parameters:
 *
 *   - char* identifier : (string) uuid / did / name of the required schema
 * Returns:
 *   - d_token_t* : (ssi_schema_result) successful operation
 */
#define TRY_CALL_SSI_GET_SCHEMA(ctx, res, identifier)                                                    \
  {                                                                                                      \
    char*      jpayload = sprintx("\"%S\"", (char*)identifier);                                          \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_SCHEMA, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
  }
#define FN_SSI_GET_SCHEMA "ssi_get_schema"

/**
 * imports a schema by providing it's DID
 *
 *
 * Parameters:
 *
 *   - char* did : (string) DID of the schema to be imported
 * Returns:
 *   - d_token_t* : (ssi_schema_result) successful operation
 */
#define TRY_CALL_SSI_SCHEMA_IMPORT(ctx, res, did)                                                           \
  {                                                                                                         \
    char*      jpayload = sprintx("\"%S\"", (char*)did);                                                    \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_SCHEMA_IMPORT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                        \
    if (r) return r;                                                                                        \
  }
#define FN_SSI_SCHEMA_IMPORT "ssi_schema_import"

/**
 * stores an entry in the database that shows that current user has accepted given terms
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (string) the data object
 * Returns:
 *   - char* : (string) successful operation
 */
#define TRY_CALL_SSI_TERMS_ACCEPT(ctx, _res, data)                                                         \
  {                                                                                                        \
    d_token_t* res;                                                                                        \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                                \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_TERMS_ACCEPT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                       \
    if (r) return r;                                                                                       \
    _res = d_string(res);                                                                                  \
  }
#define FN_SSI_TERMS_ACCEPT "ssi_terms_accept"

/**
 * gets a setting belonging to the current principal
 *
 *
 * Parameters:
 *
 *   - char* key : (string) specifies type of setting to get
 * Returns:
 *   - d_token_t* : (any) successful operation
 */
#define TRY_CALL_SSI_GET_SETTINGS(ctx, res, key)                                                           \
  {                                                                                                        \
    char*      jpayload = sprintx("\"%S\"", (char*)key);                                                   \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_SETTINGS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                       \
    if (r) return r;                                                                                       \
  }
#define FN_SSI_GET_SETTINGS "ssi_get_settings"

/**
 * adds a setting for the current principal
 *
 *
 * Parameters:
 *
 *   - char* data : (string) the data object
 *   - char* key  : (string) specifies type of setting to create
 * Returns:
 *   - d_token_t* : (any) successful operation
 */
#define TRY_CALL_SSI_CREATE_SETTINGS(ctx, res, data, key)                                                     \
  {                                                                                                           \
    char*      jpayload = sprintx("\"%S\",\"%S\"", (char*)data, (char*)key);                                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CREATE_SETTINGS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_SSI_CREATE_SETTINGS "ssi_create_settings"

/**
 * updates a setting for the current principal
 *
 *
 * Parameters:
 *
 *   - char* data : (string) the data object
 *   - char* key  : (string) specifies type of setting to update
 * Returns:
 *   - d_token_t* : (any) successful operation
 */
#define TRY_CALL_SSI_UPDATE_SETTINGS(ctx, res, data, key)                                                     \
  {                                                                                                           \
    char*      jpayload = sprintx("\"%S\",\"%S\"", (char*)data, (char*)key);                                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_UPDATE_SETTINGS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_SSI_UPDATE_SETTINGS "ssi_update_settings"

/**
 * deletes a setting for the current principal
 *
 *
 * Parameters:
 *
 *   - char* authorization : (string) the [object Object]
 *   - char* key           : (string) specifies type of setting to delete
 * Returns:
 *   - char* : (string) successful operation
 */
#define TRY_CALL_SSI_DELETE_SETTINGS(ctx, _res, authorization, key)                                           \
  {                                                                                                           \
    d_token_t* res;                                                                                           \
    char*      jpayload = sprintx("\"%S\",\"%S\"", (char*)authorization, (char*)key);                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_DELETE_SETTINGS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
    _res = d_string(res);                                                                                     \
  }
#define FN_SSI_DELETE_SETTINGS "ssi_delete_settings"

/**
 * Will resolve the file content of an specific asset. Ensure to set the token url parameter or set the `ssi-core-file-token` header.
 *
 *
 * Parameters:
 *
 *   - char* uuid                : (string) uuid of the target file which needs to be retrieved
 *   - char* token               : (string) Access token to load the file with
 *   - char* ssi_core_file_token : (string) Access token to load the file with
 * Returns:
 *   - char* : (string) successful operation
 */
#define TRY_CALL_SSI_GET_FILE(ctx, _res, uuid, token, ssi_core_file_token)                                        \
  {                                                                                                               \
    d_token_t* res;                                                                                               \
    char*      jpayload = sprintx("\"%S\",\"%S\",\"%S\"", (char*)uuid, (char*)token, (char*)ssi_core_file_token); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_GET_FILE, jpayload, NULL, &res, NULL);            \
    _free(jpayload);                                                                                              \
    if (r) return r;                                                                                              \
    _res = d_string(res);                                                                                         \
  }
#define FN_SSI_GET_FILE "ssi_get_file"

/**
 * Uploads a file to ssi-core and returns a URL that allows to access this file without login.
 *
 *
 * Parameters:
 *
 *   - char* data : (string) the data object
 * Returns:
 *   - d_token_t* : (ssi_file_result) successful operation
 */
#define TRY_CALL_SSI_CREATE_FILE(ctx, res, data)                                                          \
  {                                                                                                       \
    char*      jpayload = sprintx("\"%S\"", (char*)data);                                                 \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_CREATE_FILE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                      \
    if (r) return r;                                                                                      \
  }
#define FN_SSI_CREATE_FILE "ssi_create_file"

/**
 * Authenticates a user with a username and password to ssi-core. To read about how to use the returned token, have a look at the [example section](#login-and-receive-a-jwt-token)
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_register) the data object
 * Returns:
 *   - d_token_t* : (ssi_login_result) successful operation
 */
#define TRY_CALL_SSI_LOGIN(ctx, res, data)                                                          \
  {                                                                                                 \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_LOGIN, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                \
    if (r) return r;                                                                                \
  }
#define FN_SSI_LOGIN "ssi_login"

/**
 * Authenticates a user with biometric authentication to ssi-core. To read about how to use the returned token, have a look at the [example section](#login-and-receive-a-jwt-token)
 *
 *
 * Parameters:
 *
 *   - d_token_t* data         : (ssi_login_biometric) the data object
 *   - char*      x_user_agent : (string) user agent for FaceTec api
 *   - char*      x_device_key : (string) device key for FaceTec api
 * Returns:
 *   - d_token_t* : (ssi_login_result) successful operation
 */
#define TRY_CALL_SSI_LOGIN_BIOMETRIC(ctx, res, data, x_user_agent, x_device_key)                                    \
  {                                                                                                                 \
    char*      jpayload = sprintx("%j,\"%S\",\"%S\"", (d_token_t*) data, (char*)x_user_agent, (char*)x_device_key); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_LOGIN_BIOMETRIC, jpayload, NULL, &res, NULL);       \
    _free(jpayload);                                                                                                \
    if (r) return r;                                                                                                \
  }
#define FN_SSI_LOGIN_BIOMETRIC "ssi_login_biometric"

/**
 * enables biometric authentication by registering a biometricId for current account
 *
 *
 * Parameters:
 *
 *   - d_token_t* data : (ssi_login_biometric_activate) the data object
 * Returns:
 *   - char* : (string) successful operation
 */
#define TRY_CALL_SSI_LOGIN_BIOMETRIC_ACTIVATE(ctx, _res, data)                                                         \
  {                                                                                                                    \
    d_token_t* res;                                                                                                    \
    char*      jpayload = sprintx("%j", (d_token_t*) data);                                                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_LOGIN_BIOMETRIC_ACTIVATE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                   \
    if (r) return r;                                                                                                   \
    _res = d_string(res);                                                                                              \
  }
#define FN_SSI_LOGIN_BIOMETRIC_ACTIVATE "ssi_login_biometric_activate"

/**
 * disables biometric authentication by removing biometricId of current account
 *
 * Returns:
 *   - char* : (string) successful operation
 */
#define TRY_CALL_SSI_LOGIN_BIOMETRIC_DEACTIVATE(ctx, _res)                                                         \
  {                                                                                                                \
    d_token_t* res;                                                                                                \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_LOGIN_BIOMETRIC_DEACTIVATE, "", NULL, &res, NULL); \
    if (r) return r;                                                                                               \
    _res = d_string(res);                                                                                          \
  }
#define FN_SSI_LOGIN_BIOMETRIC_DEACTIVATE "ssi_login_biometric_deactivate"

/**
 * Invalidates auth token cookie if it is set for this client.
 *
 * Returns:
 *   - char* : (string) successful operation
 */
#define TRY_CALL_SSI_LOGOUT(ctx, _res)                                                         \
  {                                                                                            \
    d_token_t* res;                                                                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SSI_LOGOUT, "", NULL, &res, NULL); \
    if (r) return r;                                                                           \
    _res = d_string(res);                                                                      \
  }
#define FN_SSI_LOGOUT "ssi_logout"

/**
 * clears the incubed cache (usually found in the .in3-folder)
 *
 * Returns:
 *   - bool : (bool) true indicating the success
 */
#define TRY_CALL_IN3_CACHECLEAR(ctx, _res)                                                         \
  {                                                                                                \
    d_token_t* res;                                                                                \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_CACHECLEAR, "", NULL, &res, NULL); \
    if (r) return r;                                                                               \
    _res = d_int(res);                                                                             \
  }
#define FN_IN3_CACHECLEAR "in3_cacheClear"

/**
 * Returns the underlying client version. See [web3_clientversion](https://eth.wiki/json-rpc/API#web3_clientversion) for spec.
 *
 * Returns:
 *   - char* : (string) when connected to the incubed-network, `Incubed/<Version>` will be returned, but in case of a direct enpoint, its's version will be used.
 */
#define TRY_CALL_WEB3_CLIENTVERSION(ctx, _res)                                                         \
  {                                                                                                    \
    d_token_t* res;                                                                                    \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WEB3_CLIENTVERSION, "", NULL, &res, NULL); \
    if (r) return r;                                                                                   \
    _res = d_string(res);                                                                              \
  }
#define FN_WEB3_CLIENTVERSION "web3_clientVersion"

/**
 * keccak
 *
 * Returns:
 *   - d_token_t* : (undefined) the result
 */
#define TRY_CALL_KECCAK(ctx, res)                                                          \
  {                                                                                        \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_KECCAK, "", NULL, &res, NULL); \
    if (r) return r;                                                                       \
  }
#define FN_KECCAK "keccak"

/**
 * Returns Keccak-256 (not the standardized SHA3-256) of the given data.
 *
 * See [web3_sha3](https://eth.wiki/json-rpc/API#web3_sha3) for spec.
 *
 * No proof needed, since the client will execute this locally.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t data : (bytes) data to hash
 * Returns:
 *   - bytes_t : (bytes) the 32byte hash of the data
 */
#define TRY_CALL_WEB3_SHA3(ctx, _res, data)                                                         \
  {                                                                                                 \
    d_token_t* res;                                                                                 \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) data);                                        \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WEB3_SHA3, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                \
    if (r) return r;                                                                                \
    _res = d_bytes(res);                                                                            \
  }
#define FN_WEB3_SHA3 "web3_sha3"

/**
 * Returns base58 encoded data
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t data : (bytes) data to encode
 * Returns:
 *   - char* : (string) the encoded data
 */
#define TRY_CALL_IN3_BASE58_ENCODE(ctx, _res, data)                                                         \
  {                                                                                                         \
    d_token_t* res;                                                                                         \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) data);                                                \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_BASE58_ENCODE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                        \
    if (r) return r;                                                                                        \
    _res = d_string(res);                                                                                   \
  }
#define FN_IN3_BASE58_ENCODE "in3_base58_encode"

/**
 * Returns base58 decoded data
 *
 *
 *
 * Parameters:
 *
 *   - char* data : (string) data to decode
 * Returns:
 *   - bytes_t : (bytes) the decoded bytes
 */
#define TRY_CALL_IN3_BASE58_DECODE(ctx, _res, data)                                                         \
  {                                                                                                         \
    d_token_t* res;                                                                                         \
    char*      jpayload = sprintx("\"%S\"", (char*)data);                                                   \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_BASE58_DECODE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                        \
    if (r) return r;                                                                                        \
    _res = d_bytes(res);                                                                                    \
  }
#define FN_IN3_BASE58_DECODE "in3_base58_decode"

/**
 * Returns base64 encoded data
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t data : (bytes) data to encode
 * Returns:
 *   - char* : (string) the encoded data
 */
#define TRY_CALL_IN3_BASE64_ENCODE(ctx, _res, data)                                                         \
  {                                                                                                         \
    d_token_t* res;                                                                                         \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) data);                                                \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_BASE64_ENCODE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                        \
    if (r) return r;                                                                                        \
    _res = d_string(res);                                                                                   \
  }
#define FN_IN3_BASE64_ENCODE "in3_base64_encode"

/**
 * Returns base64 decoded data
 *
 *
 *
 * Parameters:
 *
 *   - char* data : (string) data to decode
 * Returns:
 *   - bytes_t : (bytes) the decoded bytes
 */
#define TRY_CALL_IN3_BASE64_DECODE(ctx, _res, data)                                                         \
  {                                                                                                         \
    d_token_t* res;                                                                                         \
    char*      jpayload = sprintx("\"%S\"", (char*)data);                                                   \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_BASE64_DECODE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                        \
    if (r) return r;                                                                                        \
    _res = d_bytes(res);                                                                                    \
  }
#define FN_IN3_BASE64_DECODE "in3_base64_decode"

/**
 * Returns sha-256 of the given data.
 *
 * No proof needed, since the client will execute this locally.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t data : (bytes) data to hash
 * Returns:
 *   - bytes_t : (bytes) the 32byte hash of the data
 */
#define TRY_CALL_SHA256(ctx, _res, data)                                                         \
  {                                                                                              \
    d_token_t* res;                                                                              \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) data);                                     \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_SHA256, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                             \
    if (r) return r;                                                                             \
    _res = d_bytes(res);                                                                         \
  }
#define FN_SHA256 "sha256"

/**
 * sends a simple http-request. This is used internally to fetch data from REST-APIs.
 *
 *
 * Parameters:
 *
 *   - char*      method  : (string) the HTTP-method to use like 'GET', 'POST', 'PUT', 'DELETE',...
 *   - char*      url     : (string) the url of the endpoint
 *   - char*      payload : (string) the payload or null, if it does not apply
 *   - d_token_t* headers : (string) a array of additional headers to send. each header must be a string in the form `Key: Value`
 * Returns:
 *   - d_token_t* : (any) the response will depend on the http-response. If the data are json-data, the json-object will the response.
 */
#define TRY_CALL_IN3_HTTP(ctx, res, method, url, payload, headers)                                                             \
  {                                                                                                                            \
    char*      jpayload = sprintx("\"%S\",\"%S\",\"%S\",%j", (char*)method, (char*)url, (char*)payload, (d_token_t*) headers); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_HTTP, jpayload, NULL, &res, NULL);                             \
    _free(jpayload);                                                                                                           \
    if (r) return r;                                                                                                           \
  }
#define FN_IN3_HTTP "in3_http"

/**
 * based on the [ABI-encoding](https://solidity.readthedocs.io/en/v0.5.3/abi-spec.html) used by solidity, this function encodes the value given and returns it as hexstring.
 *
 *
 * Parameters:
 *
 *   - char*      signature  : (string) the signature of the function. e.g. `getBalance(uint256)`. The format is the same as used by solidity to create the functionhash. optional you can also add the return type, which in this case is ignored.
 *   - d_token_t* parameters : (any) a array of arguments. the number of arguments must match the arguments in the signature.
 * Returns:
 *   - char* : (string) the ABI-encoded data as hex including the 4 byte function-signature. These data can be used for `eth_call` or to send a transaction.
 */
#define TRY_CALL_IN3_ABIENCODE(ctx, _res, signature, parameters)                                        \
  {                                                                                                     \
    d_token_t* res;                                                                                     \
    char*      jpayload = sprintx("\"%S\",%j", (char*)signature, (d_token_t*) parameters);              \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_ABIENCODE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                    \
    if (r) return r;                                                                                    \
    _res = d_string(res);                                                                               \
  }
#define FN_IN3_ABIENCODE "in3_abiEncode"

/**
 * based on the [ABI-encoding](https://solidity.readthedocs.io/en/v0.5.3/abi-spec.html) used by solidity, this function decodes the bytes given and returns it as array of values.
 *
 *
 * Parameters:
 *
 *   - char*   signature : (string) the signature of the function. e.g. `uint256`, `(address,string,uint256)` or `getBalance(address):uint256`. If the complete functionhash is given, only the return-part will be used.
 *   - bytes_t data      : (bytes) the data to decode (usually the result of a eth_call)
 *   - bytes_t topics    : (bytes) in case of an even the topics (concatinated to max 4x32bytes). This is used if indexed.arguments are used.
 * Returns:
 *   - d_token_t* : (any) a array with the values after decodeing.
 */
#define TRY_CALL_IN3_ABIDECODE(ctx, res, signature, data, topics)                                              \
  {                                                                                                            \
    char*      jpayload = sprintx("\"%S\",\"%B\",\"%B\"", (char*)signature, (bytes_t) data, (bytes_t) topics); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_ABIDECODE, jpayload, NULL, &res, NULL);        \
    _free(jpayload);                                                                                           \
    if (r) return r;                                                                                           \
  }
#define FN_IN3_ABIDECODE "in3_abiDecode"

/**
 * rlp decode the data
 *
 *
 * Parameters:
 *
 *   - bytes_t data : (bytes) input data
 * Returns:
 *   - d_token_t* : (any) a array with the values after decodeing. The result is either a hex-string or an array.
 */
#define TRY_CALL_IN3_RLPDECODE(ctx, res, data)                                                          \
  {                                                                                                     \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) data);                                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_RLPDECODE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                    \
    if (r) return r;                                                                                    \
  }
#define FN_IN3_RLPDECODE "in3_rlpDecode"

/**
 * decodes a raw transaction and returns the values. The transaction may be a signed or unsigned tx. In case of a signed transaction, the from-address will be calculated along with many other helpful values.
 *
 *
 * Parameters:
 *
 *   - bytes_t data : (bytes) input data
 * Returns:
 *   - d_token_t* : (eth_tx_decoded) the decoded transaction.
 */
#define TRY_CALL_IN3_DECODETX(ctx, res, data)                                                          \
  {                                                                                                    \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) data);                                           \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_DECODETX, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                   \
    if (r) return r;                                                                                   \
  }
#define FN_IN3_DECODETX "in3_decodeTx"

/**
 * Will convert an upper or lowercase Ethereum address to a checksum address.  (See [EIP55](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md) )
 *
 *
 * Parameters:
 *
 *   - uint8_t* address    : (address) the address to convert.
 *   - bool     useChainId : (bool) if true, the chainId is integrated as well (See [EIP1191](https://github.com/ethereum/EIPs/issues/1121) )
 * Returns:
 *   - bytes_t : (bytes) the address-string using the upper/lowercase hex characters.
 */
#define TRY_CALL_IN3_CHECKSUMADDRESS(ctx, _res, address, useChainId)                                          \
  {                                                                                                           \
    d_token_t* res;                                                                                           \
    char*      jpayload = sprintx("\"%B\",%i", bytes(address, 20), (int) useChainId);                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_CHECKSUMADDRESS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
    _res = d_bytes(res);                                                                                      \
  }
#define FN_IN3_CHECKSUMADDRESS "in3_checksumAddress"

/**
 * converts the given value into wei.
 *
 *
 * Parameters:
 *
 *   - char* value : (string) the value, which may be floating number as string
 *   - char* unit  : (string) the unit of the value, which must be one of `wei`, `kwei`,  `Kwei`,  `babbage`,  `femtoether`,  `mwei`,  `Mwei`,  `lovelace`,  `picoether`,  `gwei`,  `Gwei`,  `shannon`,  `nanoether`,  `nano`,  `szabo`,  `microether`,  `micro`,  `finney`,  `milliether`,  `milli`,  `ether`,  `eth`,  `kether`,  `grand`,  `mether`,  `gether` or  `tether`
 * Returns:
 *   - bytes_t : (uint256) the value in wei as hex.
 */
#define TRY_CALL_IN3_TOWEI(ctx, _res, value, unit)                                                  \
  {                                                                                                 \
    d_token_t* res;                                                                                 \
    char*      jpayload = sprintx("\"%S\",\"%S\"", (char*)value, (char*)unit);                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_TOWEI, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                \
    if (r) return r;                                                                                \
    _res = d_bytes(res);                                                                            \
  }
#define FN_IN3_TOWEI "in3_toWei"

/**
 * converts a given uint (also as hex) with a wei-value into a specified unit.
 *
 *
 * Parameters:
 *
 *   - bytes_t value  : (uint256) the value in wei
 *   - char*   unit   : (string) the unit of the target value, which must be one of `wei`, `kwei`,  `Kwei`,  `babbage`,  `femtoether`,  `mwei`,  `Mwei`,  `lovelace`,  `picoether`,  `gwei`,  `Gwei`,  `shannon`,  `nanoether`,  `nano`,  `szabo`,  `microether`,  `micro`,  `finney`,  `milliether`,  `milli`,  `ether`,  `eth`,  `kether`,  `grand`,  `mether`,  `gether` or  `tether`
 *   - bytes_t digits : (int) fix number of digits after the comma. If left out, only as many as needed will be included.
 * Returns:
 *   - d_token_t* : (double) the value as string.
 */
#define TRY_CALL_IN3_FROMWEI(ctx, res, value, unit, digits)                                                \
  {                                                                                                        \
    char*      jpayload = sprintx("\"%B\",\"%S\",\"%B\"", (bytes_t) value, (char*)unit, (bytes_t) digits); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_FROMWEI, jpayload, NULL, &res, NULL);      \
    _free(jpayload);                                                                                       \
    if (r) return r;                                                                                       \
  }
#define FN_IN3_FROMWEI "in3_fromWei"

/**
 * calculates the address of a contract about to deploy. The address depends on the senders nonce.
 *
 *
 * Parameters:
 *
 *   - uint8_t* sender : (address) the sender of the transaction
 *   - uint64_t nonce  : (uint64) the nonce of the sender during deployment
 * Returns:
 *   - uint8_t* : (address) the address of the deployed contract
 */
#define TRY_CALL_IN3_CALCDEPLOYADDRESS(ctx, _res, sender, nonce)                                                \
  {                                                                                                             \
    d_token_t* res;                                                                                             \
    char*      jpayload = sprintx("\"%B\",\"%U\"", bytes(sender, 20), (uint64_t)nonce);                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_IN3_CALCDEPLOYADDRESS, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                            \
    if (r) return r;                                                                                            \
    _res = d_bytes(res).data;                                                                                   \
  }
#define FN_IN3_CALCDEPLOYADDRESS "in3_calcDeployAddress"

/**
 * Returns the current network id.
 *
 * Returns:
 *   - uint64_t : (uint64) the network id
 */
#define TRY_CALL_NET_VERSION(ctx, _res)                                                         \
  {                                                                                             \
    d_token_t* res;                                                                             \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_NET_VERSION, "", NULL, &res, NULL); \
    if (r) return r;                                                                            \
    _res = d_long(res);                                                                         \
  }
#define FN_NET_VERSION "net_version"

/**
 * Creates a new DID.
 *
 *
 * Parameters:
 *
 *   - char*      method  : (string) did method to cater to.
 *   - d_token_t* options : (AuthenticationOptions) JSON string with additional information supporting the request (e.g. authentication data)
 * Returns:
 *   - char* : (string) The created DID
 */
#define TRY_CALL_DID_CREATE(ctx, _res, method, options)                                              \
  {                                                                                                  \
    d_token_t* res;                                                                                  \
    char*      jpayload = sprintx("\"%S\",%j", (char*)method, (d_token_t*) options);                 \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_DID_CREATE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                 \
    if (r) return r;                                                                                 \
    _res = d_string(res);                                                                            \
  }
#define FN_DID_CREATE "did_create"

/**
 * Updates data related to a DID.
 *
 *
 * Parameters:
 *
 *   - char*      did     : (string) DID to update data for
 *   - d_token_t* options : (AuthenticationOptions) JSON string with additional information supporting the request (e.g. authentication data)
 *   - char*      payload : (string) DID document as a string (can be JSON, plain string or any other form of data representation)
 * Returns:
 *   - char* : (string) Update response as JSON string
 */
#define TRY_CALL_DID_UPDATE(ctx, _res, did, options, payload)                                            \
  {                                                                                                      \
    d_token_t* res;                                                                                      \
    char*      jpayload = sprintx("\"%S\",%j,\"%S\"", (char*)did, (d_token_t*) options, (char*)payload); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_DID_UPDATE, jpayload, NULL, &res, NULL);     \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
    _res = d_string(res);                                                                                \
  }
#define FN_DID_UPDATE "did_update"

/**
 * Fetch data about a DID. This usually returns a DID document.
 *
 *
 * Parameters:
 *
 *   - char* did : (string) DID to fetch data for
 * Returns:
 *   - char* : (string) The linked DID document as JSON string
 */
#define TRY_CALL_DID_RESOLVE(ctx, _res, did)                                                          \
  {                                                                                                   \
    d_token_t* res;                                                                                   \
    char*      jpayload = sprintx("\"%S\"", (char*)did);                                              \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_DID_RESOLVE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                  \
    if (r) return r;                                                                                  \
    _res = d_string(res);                                                                             \
  }
#define FN_DID_RESOLVE "did_resolve"

/**
 * Creates a new zero-knowledge proof credential schema.
 *
 *
 * Parameters:
 *
 *   - char*      method  : (string) did method to cater to.
 *   - d_token_t* options : (AuthenticationOptions) JSON string with additional information supporting the request (e.g. authentication data)
 *   - d_token_t* payload : (CreateCredentialSchemaPayload) serialized CreateCredentialSchemaPayload
 * Returns:
 *   - d_token_t* : (CredentialSchema) The created schema as JSON string
 */
#define TRY_CALL_CREATE_CRED_SCHEMA(ctx, res, method, options, payload)                                       \
  {                                                                                                           \
    char*      jpayload = sprintx("\"%S\",%j,%j", (char*)method, (d_token_t*) options, (d_token_t*) payload); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_CREATE_CRED_SCHEMA, jpayload, NULL, &res, NULL);  \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_CREATE_CRED_SCHEMA "create_cred_schema"

/**
 * Creates a new credential definition and stores the public part on-chain. The private part (key) needs to be stored in a safe way and must not be shared. A credential definition holds cryptographic material needed to verify proofs. Every definition is bound to one credential schema.
 *
 *
 * Parameters:
 *
 *   - char*      method  : (string) did method to cater to.
 *   - d_token_t* options : (AuthenticationOptions) JSON string with additional information supporting the request (e.g. authentication data)
 *   - d_token_t* payload : (CreateCredentialDefinitionPayload) serialized CreateCredentialDefinitionPayload
 * Returns:
 *   - d_token_t* : (CreateCredentialDefinitionResult) The created definition
 */
#define TRY_CALL_CREATE_CRED_DEFINITION(ctx, res, method, options, payload)                                      \
  {                                                                                                              \
    char*      jpayload = sprintx("\"%S\",%j,%j", (char*)method, (d_token_t*) options, (d_token_t*) payload);    \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_CREATE_CRED_DEFINITION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                             \
    if (r) return r;                                                                                             \
  }
#define FN_CREATE_CRED_DEFINITION "create_cred_definition"

/**
 * Creates a new zero-knowledge proof credential proposal. This message is the first in the credential issuance flow and is sent by the potential credential holder to the credential issuer.
 *
 *
 * Parameters:
 *
 *   - char*      method  : (string) did method to cater to.
 *   - d_token_t* options : (TypeOptions) JSON string with additional information supporting the request (e.g. authentication data)
 *   - d_token_t* payload : (CreateCredentialProposalPayload) serialized CreateCredentialProposalPayload
 * Returns:
 *   - d_token_t* : (CredentialProposal) The proposal
 */
#define TRY_CALL_CREATE_CRED_PROPOSAL(ctx, res, method, options, payload)                                      \
  {                                                                                                            \
    char*      jpayload = sprintx("\"%S\",%j,%j", (char*)method, (d_token_t*) options, (d_token_t*) payload);  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_CREATE_CRED_PROPOSAL, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                           \
    if (r) return r;                                                                                           \
  }
#define FN_CREATE_CRED_PROPOSAL "create_cred_proposal"

/**
 * Creates a CredentialOffer message. A CredentialOffer is sent by an issuer and is the response to a CredentialProposal. The CredentialOffer specifies which schema and definition the issuer is capable and willing to use for credential issuance.
 *
 *
 * Parameters:
 *
 *   - char*      method  : (string) did method to cater to.
 *   - d_token_t* options : (TypeOptions) JSON string with additional information supporting the request (e.g. authentication data)
 *   - d_token_t* payload : (OfferCredentialPayload) serialized OfferCredentialPayload
 * Returns:
 *   - d_token_t* : (CredentialOffer) The created offer
 */
#define TRY_CALL_CREATE_CRED_OFFER(ctx, res, method, options, payload)                                        \
  {                                                                                                           \
    char*      jpayload = sprintx("\"%S\",%j,%j", (char*)method, (d_token_t*) options, (d_token_t*) payload); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_CREATE_CRED_OFFER, jpayload, NULL, &res, NULL);   \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_CREATE_CRED_OFFER "create_cred_offer"

/**
 * Requests a credential. This message is the response to a credential offering and is sent by the potential credential holder. It incorporates the target schema, credential definition offered by the issuer, and the encoded values the holder wants to get signed. The credential is not stored on-chain and needs to be kept private.
 *
 *
 * Parameters:
 *
 *   - char*      method  : (string) did method to cater to.
 *   - d_token_t* options : (TypeOptions) JSON string with additional information supporting the request (e.g. authentication data)
 *   - d_token_t* payload : (RequestCredentialPayload) serialized RequestCredentialPayload
 * Returns:
 *   - d_token_t* : (RequestCredentialResult) A JSON consisting of the CredentialRequest and CredentialSecretsBlindingFactors (to be stored at the proofer's site in a private manner)
 */
#define TRY_CALL_REQUEST_CRED(ctx, res, method, options, payload)                                             \
  {                                                                                                           \
    char*      jpayload = sprintx("\"%S\",%j,%j", (char*)method, (d_token_t*) options, (d_token_t*) payload); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_REQUEST_CRED, jpayload, NULL, &res, NULL);        \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_REQUEST_CRED "request_cred"

/**
 * Creates a new revocation registry definition and stores it on-chain. The definition consists of a public and a private part. The public part holds the cryptographic material needed to create non-revocation proofs. The private part needs to reside with the registry owner and is used to revoke credentials. Note that options.identity needs to be whitelisted for this function.
 *
 *
 * Parameters:
 *
 *   - char*      method  : (string) did method to cater to.
 *   - d_token_t* options : (AuthenticationOptions) JSON string with additional information supporting the request (e.g. authentication data)
 *   - d_token_t* payload : (CreateRevocationRegistryDefinitionPayload) serialized CreateRevocationRegistryDefinitionPayload
 * Returns:
 *   - d_token_t* : (CreateRevocationRegistryDefinitionResult) created revocation registry definition as a JSON object as serialized CreateRevocationRegistryDefinitionResult
 */
#define TRY_CALL_CREATE_REVOCATION_REGISTRY_DEFINITION(ctx, res, method, options, payload)                                      \
  {                                                                                                                             \
    char*      jpayload = sprintx("\"%S\",%j,%j", (char*)method, (d_token_t*) options, (d_token_t*) payload);                   \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_CREATE_REVOCATION_REGISTRY_DEFINITION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                            \
    if (r) return r;                                                                                                            \
  }
#define FN_CREATE_REVOCATION_REGISTRY_DEFINITION "create_revocation_registry_definition"

/**
 * Updates a revocation registry for a zero-knowledge proof. This step is necessary after revocation one or more credentials.
 *
 *
 * Parameters:
 *
 *   - char*      method  : (string) did method to cater to.
 *   - d_token_t* options : (AuthenticationOptions) JSON string with additional information supporting the request (e.g. authentication data)
 *   - d_token_t* payload : (CreateRevocationRegistryDefinitionPayload) JSON string with information for the request
 * Returns:
 *   - d_token_t* : (CreateRevocationRegistryDefinitionResult) A JSON consisting of the CredentialRequest and CredentialSecretsBlindingFactors (to be stored at the proofer's site in a private manner)
 */
#define TRY_CALL_UPDATE_REVOCATION_REGISTRY(ctx, res, method, options, payload)                                      \
  {                                                                                                                  \
    char*      jpayload = sprintx("\"%S\",%j,%j", (char*)method, (d_token_t*) options, (d_token_t*) payload);        \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_UPDATE_REVOCATION_REGISTRY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                 \
    if (r) return r;                                                                                                 \
  }
#define FN_UPDATE_REVOCATION_REGISTRY "update_revocation_registry"

/**
 * Issues a new credential. This requires an issued schema, credential definition, an active revocation registry and a credential request message.
 *
 *
 * Parameters:
 *
 *   - char*      method  : (string) did method to cater to.
 *   - d_token_t* options : (TypeOptions) JSON string with additional information supporting the request (e.g. authentication data)
 *   - d_token_t* payload : (IssueCredentialPayload) serialized IssueCredentialPayload
 * Returns:
 *   - d_token_t* : (IssueCredentialResult) serialized IssueCredentialResult consisting of the credential, this credential's initial revocation state and the updated revocation info, only interesting for the issuer (needs to be stored privately)
 */
#define TRY_CALL_ISSUE_CRED(ctx, res, method, options, payload)                                               \
  {                                                                                                           \
    char*      jpayload = sprintx("\"%S\",%j,%j", (char*)method, (d_token_t*) options, (d_token_t*) payload); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ISSUE_CRED, jpayload, NULL, &res, NULL);          \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_ISSUE_CRED "issue_cred"

/**
 * Finsihes a credential
 *
 *
 * Parameters:
 *
 *   - char*      method  : (string) did method to cater to.
 *   - d_token_t* options : (TypeOptions) JSON string with additional information supporting the request (e.g. authentication data)
 *   - d_token_t* payload : (FinishCredentialPayload) serialized FinishCredentialPayload
 * Returns:
 *   - d_token_t* : (Credential) serialized Credential
 */
#define TRY_CALL_FINISH_CRED(ctx, res, method, options, payload)                                              \
  {                                                                                                           \
    char*      jpayload = sprintx("\"%S\",%j,%j", (char*)method, (d_token_t*) options, (d_token_t*) payload); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_FINISH_CRED, jpayload, NULL, &res, NULL);         \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_FINISH_CRED "finish_cred"

/**
 * Revokes a credential. After revocation the published revocation registry needs to be updated with information returned by this function. To revoke a credential, tbe revoker must be in possession of the private key associated with the credential's revocation registry. After revocation, the published revocation registry must be updated. Only then is the credential truly revoked. Note that options.identity needs to be whitelisted for this function.
 *
 *
 * Parameters:
 *
 *   - char*      method  : (string) did method to cater to.
 *   - d_token_t* options : (AuthenticationOptions) JSON string with additional information supporting the request (e.g. authentication data)
 *   - d_token_t* payload : (RevokeCredentialPayload) serialized RevokeCredentialPayload
 * Returns:
 *   - char* : (string) The updated revocation registry definition as a JSON object. Contains information needed to update the respective revocation registry.
 */
#define TRY_CALL_REVOKE_CRED(ctx, _res, method, options, payload)                                             \
  {                                                                                                           \
    d_token_t* res;                                                                                           \
    char*      jpayload = sprintx("\"%S\",%j,%j", (char*)method, (d_token_t*) options, (d_token_t*) payload); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_REVOKE_CRED, jpayload, NULL, &res, NULL);         \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
    _res = d_string(res);                                                                                     \
  }
#define FN_REVOKE_CRED "revoke_cred"

/**
 * Requests a zero-knowledge proof for one or more credentials issued under one or more specific schemas and is sent by a verifier to a prover. The proof request consists of the fields the verifier wants to be revealed per schema.
 *
 *
 * Parameters:
 *
 *   - char*      method  : (string) did method to cater to.
 *   - d_token_t* options : (TypeOptions) JSON string with additional information supporting the request (e.g. authentication data)
 *   - d_token_t* payload : (RequestProofPayload) serialized RequestProofPayload
 * Returns:
 *   - d_token_t* : (ProofRequest) A ProofRequest as JSON
 */
#define TRY_CALL_REQUEST_PROOF(ctx, res, method, options, payload)                                            \
  {                                                                                                           \
    char*      jpayload = sprintx("\"%S\",%j,%j", (char*)method, (d_token_t*) options, (d_token_t*) payload); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_REQUEST_PROOF, jpayload, NULL, &res, NULL);       \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_REQUEST_PROOF "request_proof"

/**
 * Presents a proof for one or more credentials. A proof presentation is the response to a proof request. The proof needs to incorporate all required fields from all required schemas requested in the proof request.
 *
 *
 * Parameters:
 *
 *   - char*      method  : (string) did method to cater to.
 *   - d_token_t* options : (TypeOptions) JSON string with additional information supporting the request (e.g. authentication data)
 *   - d_token_t* payload : (PresentProofPayload) serialized PresentProofPayload
 * Returns:
 *   - d_token_t* : (ProofPresentation) ProofPresentation as JSON
 */
#define TRY_CALL_PRESENT_PROOF(ctx, res, method, options, payload)                                            \
  {                                                                                                           \
    char*      jpayload = sprintx("\"%S\",%j,%j", (char*)method, (d_token_t*) options, (d_token_t*) payload); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_PRESENT_PROOF, jpayload, NULL, &res, NULL);       \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_PRESENT_PROOF "present_proof"

/**
 * Verifies one or multiple proofs sent in a proof presentation.
 *
 *
 * Parameters:
 *
 *   - char*      method  : (string) did method to cater to.
 *   - d_token_t* options : (TypeOptions) JSON string with additional information supporting the request (e.g. authentication data)
 *   - d_token_t* payload : (ValidateProofPayload) serialized ValidateProofPayload
 * Returns:
 *   - d_token_t* : (ProofVerification) A JSON object representing a ProofVerification type, specifying whether verification was successful
 */
#define TRY_CALL_VERIFY_PROOF(ctx, res, method, options, payload)                                             \
  {                                                                                                           \
    char*      jpayload = sprintx("\"%S\",%j,%j", (char*)method, (d_token_t*) options, (d_token_t*) payload); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_VERIFY_PROOF, jpayload, NULL, &res, NULL);        \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_VERIFY_PROOF "verify_proof"

/**
 * executes or prepares a transaction for a wallet.
 *
 * This is the main function to execute or send a transaction.
 * The resulting data can be used as input data again. This allows to collect signatures or simply split the preparing of a transaction and the sending.
 * But in most case simply using the exec-level `receipt` can do it all in one step and return the receipt.
 *
 * This is an example on how to collect signatures:
 *
 * ```sh
 * # sign the transaction with one key and store the tx_data in a file
 * equs send -to 0x... -value 1.2eth -pk pk1.json --default_exec=prepare > tx.json
 *
 * # this file could now be send to other signers, where they can sign with their keys
 * equs wallet_exec ./tx.json -pk pk2.json --default_exec=prepare > tx_signed_both.json
 *
 * # now anybody can send the tx and wait for the receipt
 * equs wallet_exec ./tx_signed_both.json -pk gas_relay.json --default_exec=receipt | jq
 * ```
 *
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx     : (tx_data) the description of the transaction. As minimum only the inputs are needed.
 *                         But in order to sign with multiple parties the definition can be passed to combined multiple signatures
 *
 *   - char*      exec   : (string) the execution level when sending transactions trough the wallet.
 *                             - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                             - `sign` - the raw transaction is signed
 *                             - `send` - the transaction is send and the transactionHash is added
 *                             - `receipt` - the function will wait until the receipt has been found
 *
 *   - uint8_t*   wallet : (address) the wallet to be used. I ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) the transaction-state
 */
#define TRY_CALL_WALLET_EXEC(ctx, res, tx, exec, wallet)                                                \
  {                                                                                                     \
    char*      jpayload = sprintx("%j,\"%S\",\"%B\"", (d_token_t*) tx, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_EXEC, jpayload, NULL, &res, NULL);   \
    _free(jpayload);                                                                                    \
    if (r) return r;                                                                                    \
  }
#define FN_WALLET_EXEC "wallet_exec"

/**
 * sends or prepares a transaction for a wallet.
 *
 * This is the same as wallet_exec, but only requires the input.
 *
 * The resulting data can be used as input data for wallet_exec again. This allows to collect signatures or simply split the preparing of a transaction and the sending.
 * But in most case simply using the exec-level `receipt` can do it all in one step and return the receipt.
 *
 * This is an example on how to collect signatures:
 *
 * ```sh
 * # sign the transaction with one key and store the tx_data in a file
 * equs send -to 0x... -value 1.2eth -pk pk1.json --default_exec=prepare > tx.json
 *
 * # this file could now be send to other signers, where they can sign with their keys
 * equs wallet_exec ./tx.json -pk pk2.json --default_exec=prepare > tx_signed_both.json
 *
 * # now anybody can send the tx and wait for the receipt
 * equs wallet_exec ./tx_signed_both.json -pk gas_relay.json --default_exec=receipt | jq
 * ```
 *
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx     : (tx_input) the description of the transaction. As minimum only the inputs are needed.
 *                         But in order to sign with multiple parties the definition can be passed to combined multiple signatures
 *
 *   - char*      exec   : (string) the execution level when sending transactions trough the wallet.
 *                             - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                             - `sign` - the raw transaction is signed
 *                             - `send` - the transaction is send and the transactionHash is added
 *                             - `receipt` - the function will wait until the receipt has been found
 *
 *   - uint8_t*   wallet : (address) the wallet to be used. I ommited,  either the wallet as defined in the input-data is used, or the default-wallet as configured.
 * Returns:
 *   - d_token_t* : (tx_data) the transaction-state
 */
#define TRY_CALL_WALLET_SEND(ctx, res, tx, exec, wallet)                                                \
  {                                                                                                     \
    char*      jpayload = sprintx("%j,\"%S\",\"%B\"", (d_token_t*) tx, (char*)exec, bytes(wallet, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SEND, jpayload, NULL, &res, NULL);   \
    _free(jpayload);                                                                                    \
    if (r) return r;                                                                                    \
  }
#define FN_WALLET_SEND "wallet_send"

/**
 * returns the balance for the specified account or wallet. If the wallet support l1 and l2 layer, it will return the sum of both.
 *
 *
 * Parameters:
 *
 *   - char*    token  : (string) The name or address of the token or NULL (or "ETH") if eth-balance is requested.
 *   - bool     dec    : (bool) if true the return value will be a double
 *   - uint8_t* wallet : (address) the wallet or account to be used. I ommited the default-wallet as configured.
 * Returns:
 *   - bytes_t : (uint256) the current balance
 */
#define TRY_CALL_WALLET_GET_BALANCE(ctx, _res, token, dec, wallet)                                           \
  {                                                                                                          \
    d_token_t* res;                                                                                          \
    char*      jpayload = sprintx("\"%S\",%i,\"%B\"", (char*)token, (int) dec, bytes(wallet, 20));           \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_GET_BALANCE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                         \
    if (r) return r;                                                                                         \
    _res = d_bytes(res);                                                                                     \
  }
#define FN_WALLET_GET_BALANCE "wallet_get_balance"

/**
 * applies the changes of the specified wallet-config.
 *
 * This function will use the wallet config passed as first argument and compare it with wallet in the config. For each change a transaction willbe created.
 * If there are more than one transaction they will be bundled to one transaction useing the multisend-contract ( which must be configured in the wallet_deploy-section).
 * This method can be used to update almost any property including updating the master_copy.
 *
 *
 *
 * Parameters:
 *
 *   - d_token_t* new_config : (ms_def) The config of the changes of the wallet.
 *   - char*      exec       : (string) the execution level when sending transactions trough the wallet.
 *                                 - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                                 - `sign` - the raw transaction is signed
 *                                 - `send` - the transaction is send and the transactionHash is added
 *                                 - `receipt` - the function will wait until the receipt has been found
 *
 * Returns:
 *   - d_token_t* : (wallet_update) the updated config.
 */
#define TRY_CALL_WALLET_APPLY(ctx, res, new_config, exec)                                              \
  {                                                                                                    \
    char*      jpayload = sprintx("%j,\"%S\"", (d_token_t*) new_config, (char*)exec);                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_APPLY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                   \
    if (r) return r;                                                                                   \
  }
#define FN_WALLET_APPLY "wallet_apply"

/**
 * Starts a recovery process to replace a lost key with a new key.
 *
 * This requires a signer registered matching at least one of the recovery keys in the wallet.
 *
 *
 *
 * Parameters:
 *
 *   - uint8_t* old_owner    : (address) The address of the owner which should be replaced
 *   - uint8_t* new_owner    : (address) The address of the new owner
 *   - uint8_t* recovery_key : (address) The address of the recovery key used. If null, then  this will be detected based on the current registered signers.
 *   - uint8_t* wallet       : (address) the wallet or account to be used. I ommited the default-wallet as configured.
 *   - char*    exec         : (string) the execution level when sending transactions trough the wallet.
 *                                 - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                                 - `sign` - the raw transaction is signed
 *                                 - `send` - the transaction is send and the transactionHash is added
 *                                 - `receipt` - the function will wait until the receipt has been found
 *
 * Returns:
 *   - d_token_t* : (tx_data) the tx_data with the resulting tx.
 */
#define TRY_CALL_WALLET_RECOVER(ctx, res, old_owner, new_owner, recovery_key, wallet, exec)                                                                                   \
  {                                                                                                                                                                           \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\",\"%B\",\"%S\"", bytes(old_owner, 20), bytes(new_owner, 20), bytes(recovery_key, 20), bytes(wallet, 20), (char*)exec); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_RECOVER, jpayload, NULL, &res, NULL);                                                                      \
    _free(jpayload);                                                                                                                                                          \
    if (r) return r;                                                                                                                                                          \
  }
#define FN_WALLET_RECOVER "wallet_recover"

/**
 * Checks for multisig for any ongoing recovery-process and reacts by creating a transaction.
 * If one or mor owner key is challenged and should be replaced, but this sdk has a signer for this key registered, it will use it and create a transaction to stop it.
 * If the challenge was started by recovery key wuth a signer registered in the sdk and the challenge interval has passed the final transaction to replace the key will be created.
 *
 *
 *
 * Parameters:
 *
 *   - uint8_t* wallet : (address) the wallet or account to be used. I ommited the default-wallet as configured.
 *   - char*    exec   : (string) the execution level when sending transactions trough the wallet.
 *                           - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                           - `sign` - the raw transaction is signed
 *                           - `send` - the transaction is send and the transactionHash is added
 *                           - `receipt` - the function will wait until the receipt has been found
 *
 * Returns:
 *   - d_token_t* : (tx_data) a array of transactions. Depending on the level, those transactions are just prepared or even executed.
 */
#define TRY_CALL_WALLET_UPDATE_RECOVERY(ctx, res, wallet, exec)                                                  \
  {                                                                                                              \
    char*      jpayload = sprintx("\"%B\",\"%S\"", bytes(wallet, 20), (char*)exec);                              \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_UPDATE_RECOVERY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                             \
    if (r) return r;                                                                                             \
  }
#define FN_WALLET_UPDATE_RECOVERY "wallet_update_recovery"

/**
 * returns the wallet from the current configuration.
 *
 *
 * Parameters:
 *
 *   - uint8_t* account : (address) the address of the wallet
 * Returns:
 *   - d_token_t* : (ms_def) the wallet-configuration
 */
#define TRY_CALL_WALLET_GET(ctx, res, account)                                                       \
  {                                                                                                  \
    char*      jpayload = sprintx("\"%B\"", bytes(account, 20));                                     \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_GET, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                 \
    if (r) return r;                                                                                 \
  }
#define FN_WALLET_GET "wallet_get"

/**
 * returns an array of owners-address with the specified role
 *
 *
 * Parameters:
 *
 *   - char*    role    : (string) the role of the owner as bitmask
 *   - uint8_t* account : (address) the address of the wallet
 * Returns:
 *   - d_token_t* : (undefined) the result
 */
#define TRY_CALL_WALLET_GET_OWNERS_FOR_ROLE(ctx, res, role, account)                                                 \
  {                                                                                                                  \
    char*      jpayload = sprintx("\"%S\",\"%B\"", (char*)role, bytes(account, 20));                                 \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_GET_OWNERS_FOR_ROLE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                 \
    if (r) return r;                                                                                                 \
  }
#define FN_WALLET_GET_OWNERS_FOR_ROLE "wallet_get_owners_for_role"

/**
 * reads the history and all events for the wallet.
 *
 *
 * Parameters:
 *
 *   - bool     force_update : (bool) if true the history will also be update otherwise it will be taken from the cache and only created if it does not exist yet
 *   - bool     only_new     : (bool) if true, only new events will be returned
 *   - uint8_t* account      : (address) the address of the wallet
 * Returns:
 *   - d_token_t* : (wallet_tx) a array with all events since the creation of the wallet.
 */
#define TRY_CALL_WALLET_HISTORY(ctx, res, force_update, only_new, account)                                 \
  {                                                                                                        \
    char*      jpayload = sprintx("%i,%i,\"%B\"", (int) force_update, (int) only_new, bytes(account, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_HISTORY, jpayload, NULL, &res, NULL);   \
    _free(jpayload);                                                                                       \
    if (r) return r;                                                                                       \
  }
#define FN_WALLET_HISTORY "wallet_history"

/**
 * transfers nft, in layer 1 that is 721 transferFrom
 *
 *
 *
 * Parameters:
 *
 *   - d_token_t* nft    : (nft) The address of the owner which should be replaced
 *   - uint8_t*   to     : (address) The address of the new owner
 *   - uint8_t*   from   : (address) The address of the current owner. Default is tx sender
 *   - uint8_t*   wallet : (address) the wallet or account to be used. I ommited the default-wallet as configured.
 *   - char*      exec   : (string) the execution level when sending transactions trough the wallet.
 *                             - `prepare` - the transaction is not signed, but for the multisig signatures all useable signatures are collected.
 *                             - `sign` - the raw transaction is signed
 *                             - `send` - the transaction is send and the transactionHash is added
 *                             - `receipt` - the function will wait until the receipt has been found
 *
 * Returns:
 *   - d_token_t* : (tx_data) the tx_data with the resulting tx.
 */
#define TRY_CALL_WALLET_TRANSFER_NFT(ctx, res, nft, to, from, wallet, exec)                                                                            \
  {                                                                                                                                                    \
    char*      jpayload = sprintx("%j,\"%B\",\"%B\",\"%B\",\"%S\"", (d_token_t*) nft, bytes(to, 20), bytes(from, 20), bytes(wallet, 20), (char*)exec); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_TRANSFER_NFT, jpayload, NULL, &res, NULL);                                          \
    _free(jpayload);                                                                                                                                   \
    if (r) return r;                                                                                                                                   \
  }
#define FN_WALLET_TRANSFER_NFT "wallet_transfer_nft"

/**
 * get requests to the uri containing the metadata assets, checks through 165 if metadata is supported
 *
 *
 *
 * Parameters:
 *
 *   - d_token_t* nft : (nft) nft for which you want the uri
 * Returns:
 *   - char* : (string) the uri assign to the token
 */
#define TRY_CALL_WALLET_GET_NFT_METADATA_URI(ctx, _res, nft)                                                          \
  {                                                                                                                   \
    d_token_t* res;                                                                                                   \
    char*      jpayload = sprintx("%j", (d_token_t*) nft);                                                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_GET_NFT_METADATA_URI, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                  \
    if (r) return r;                                                                                                  \
    _res = d_string(res);                                                                                             \
  }
#define FN_WALLET_GET_NFT_METADATA_URI "wallet_get_nft_metadata_uri"

/**
 * checks if the given contract supports the interface signature/id according to ERC165
 *
 *
 *
 * Parameters:
 *
 *   - uint8_t* contract_address : (address) the contract address from the contract containing the interface to be checked
 *   - bytes_t  interface_id     : (bytes) the interface id that needs to be checked
 * Returns:
 *   - bool : (bool) true if the interface id is supported
 */
#define TRY_CALL_WALLET_CONTRACT_SUPPORTS_INTERFACE_165(ctx, _res, contract_address, interface_id)                               \
  {                                                                                                                              \
    d_token_t* res;                                                                                                              \
    char*      jpayload = sprintx("\"%B\",\"%B\"", bytes(contract_address, 20), (bytes_t) interface_id);                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_CONTRACT_SUPPORTS_INTERFACE_165, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                             \
    if (r) return r;                                                                                                             \
    _res = d_int(res);                                                                                                           \
  }
#define FN_WALLET_CONTRACT_SUPPORTS_INTERFACE_165 "wallet_contract_supports_interface_165"

/**
 * get requests to the uri containing the metadata assets, checks through 165 is metadata is supported
 *
 *
 *
 * Parameters:
 *
 *   - char* uri : (string) nft for which you want the uri
 * Returns:
 *   - char* : (string) json string with the stored metadata format
 */
#define TRY_CALL_WALLET_GET_NFT_METADATA_FROM_URI(ctx, _res, uri)                                                          \
  {                                                                                                                        \
    d_token_t* res;                                                                                                        \
    char*      jpayload = sprintx("\"%S\"", (char*)uri);                                                                   \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_GET_NFT_METADATA_FROM_URI, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                       \
    if (r) return r;                                                                                                       \
    _res = d_string(res);                                                                                                  \
  }
#define FN_WALLET_GET_NFT_METADATA_FROM_URI "wallet_get_nft_metadata_from_uri"

/**
 * todo
 *
 *
 * Parameters:
 *
 *   - char*    status         : (string) the status of exchange provision
 *   - char*    base_currency  : (string) todo
 *   - char*    quote_currency : (string) todo
 *   - uint32_t offset         : (uint32) todo
 *   - uint32_t limit          : (uint32) todo
 * Returns:
 *   - d_token_t* : (ws_exchange_provision) todo
 */
#define TRY_CALL_WALLET_SERVICE_LIST_EXCHANGE_PROVISIONS(ctx, res, status, base_currency, quote_currency, offset, limit)                                                \
  {                                                                                                                                                                     \
    char*      jpayload = sprintx("\"%S\",\"%S\",\"%S\",\"%u\",\"%u\"", (char*)status, (char*)base_currency, (char*)quote_currency, (uint32_t)offset, (uint32_t)limit); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_LIST_EXCHANGE_PROVISIONS, jpayload, NULL, &res, NULL);                                       \
    _free(jpayload);                                                                                                                                                    \
    if (r) return r;                                                                                                                                                    \
  }
#define FN_WALLET_SERVICE_LIST_EXCHANGE_PROVISIONS "wallet_service_list_exchange_provisions"

/**
 * retrieve the exchange provision
 *
 *
 * Parameters:
 *
 *   - char* id : (string) id of the exchange provision
 * Returns:
 *   - d_token_t* : (ws_exchange_provision) the exchange provision
 */
#define TRY_CALL_WALLET_SERVICE_GET_EXCHANGE_PROVISION(ctx, res, id)                                                            \
  {                                                                                                                             \
    char*      jpayload = sprintx("\"%S\"", (char*)id);                                                                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_GET_EXCHANGE_PROVISION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                            \
    if (r) return r;                                                                                                            \
  }
#define FN_WALLET_SERVICE_GET_EXCHANGE_PROVISION "wallet_service_get_exchange_provision"

/**
 * cancel the exchange provision
 *
 *
 * Parameters:
 *
 *   - char* id : (string) id of the exchange provision
 * Returns:
 *   - d_token_t* : (ws_exchange_provision_detail) the exchange provision
 */
#define TRY_CALL_WALLET_SERVICE_CANCEL_EXCHANGE_PROVISION(ctx, res, id)                                                            \
  {                                                                                                                                \
    char*      jpayload = sprintx("\"%S\"", (char*)id);                                                                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_CANCEL_EXCHANGE_PROVISION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                               \
    if (r) return r;                                                                                                               \
  }
#define FN_WALLET_SERVICE_CANCEL_EXCHANGE_PROVISION "wallet_service_cancel_exchange_provision"

/**
 * create an exchange provision
 *
 *
 * Parameters:
 *
 *   - char*   wallet_id      : (string) the id of the wallet
 *   - char*   account_id     : (string) the id of the account
 *   - char*   base_currency  : (string) the base currency
 *   - char*   quote_currency : (string) the quote currency
 *   - bytes_t base_amount    : (uint256) the base ammount
 * Returns:
 *   - d_token_t* : (ws_create_exchange_provision_transaction) the exchange provision
 */
#define TRY_CALL_WALLET_SERVICE_CREATE_EXCHANGE_PROVISION(ctx, res, wallet_id, account_id, base_currency, quote_currency, base_amount)                                            \
  {                                                                                                                                                                               \
    char*      jpayload = sprintx("\"%S\",\"%S\",\"%S\",\"%S\",\"%B\"", (char*)wallet_id, (char*)account_id, (char*)base_currency, (char*)quote_currency, (bytes_t) base_amount); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_CREATE_EXCHANGE_PROVISION, jpayload, NULL, &res, NULL);                                                \
    _free(jpayload);                                                                                                                                                              \
    if (r) return r;                                                                                                                                                              \
  }
#define FN_WALLET_SERVICE_CREATE_EXCHANGE_PROVISION "wallet_service_create_exchange_provision"

/**
 * get exchange rates of base currency and quote currency
 *
 *
 * Parameters:
 *
 *   - char* base_currency  : (string) todo
 *   - char* quote_currency : (string) todo
 * Returns:
 *   - d_token_t* : (ws_rate) todo
 */
#define TRY_CALL_WALLET_SERVICE_LIST_EXCHANGE_RATES(ctx, res, base_currency, quote_currency)                                 \
  {                                                                                                                          \
    char*      jpayload = sprintx("\"%S\",\"%S\"", (char*)base_currency, (char*)quote_currency);                             \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_LIST_EXCHANGE_RATES, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                         \
    if (r) return r;                                                                                                         \
  }
#define FN_WALLET_SERVICE_LIST_EXCHANGE_RATES "wallet_service_list_exchange_rates"

/**
 * todo
 *
 *
 * Parameters:
 *
 *   - char* base_currency  : (string) todo
 *   - char* quote_currency : (string) todo
 *   - char* start_date     : (string) todo
 *   - char* end_date       : (string) todo
 * Returns:
 *   - d_token_t* : (ws_exchange_rates_history) the result of rate history search
 */
#define TRY_CALL_WALLET_SERVICE_LIST_EXCHANGE_RATES_HISTORY(ctx, res, base_currency, quote_currency, start_date, end_date)                         \
  {                                                                                                                                                \
    char*      jpayload = sprintx("\"%S\",\"%S\",\"%S\",\"%S\"", (char*)base_currency, (char*)quote_currency, (char*)start_date, (char*)end_date); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_LIST_EXCHANGE_RATES_HISTORY, jpayload, NULL, &res, NULL);               \
    _free(jpayload);                                                                                                                               \
    if (r) return r;                                                                                                                               \
  }
#define FN_WALLET_SERVICE_LIST_EXCHANGE_RATES_HISTORY "wallet_service_list_exchange_rates_history"

/**
 * get portfolio of the wallet
 *
 *
 * Parameters:
 *
 *   - char* wallet_id : (string) the wallet id
 * Returns:
 *   - d_token_t* : (ws_portfolio) the portfolio list of the wallet
 */
#define TRY_CALL_WALLET_SERVICE_GET_PORTFOLIO(ctx, res, wallet_id)                                                     \
  {                                                                                                                    \
    char*      jpayload = sprintx("\"%S\"", (char*)wallet_id);                                                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_GET_PORTFOLIO, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                   \
    if (r) return r;                                                                                                   \
  }
#define FN_WALLET_SERVICE_GET_PORTFOLIO "wallet_service_get_portfolio"

/**
 * get portfolio history
 *
 *
 * Parameters:
 *
 *   - char* start_date     : (string) todo
 *   - char* end_date       : (string) todo
 *   - char* wallet_id      : (string) the wallet id
 *   - char* base_currency  : (string) todo
 *   - char* quote_currency : (string) todo
 * Returns:
 *   - d_token_t* : (ws_portfolio_history) the portfolio list of the wallet
 */
#define TRY_CALL_WALLET_SERVICE_GET_PORTFOLIO_HISTORY(ctx, res, start_date, end_date, wallet_id, base_currency, quote_currency)                                             \
  {                                                                                                                                                                         \
    char*      jpayload = sprintx("\"%S\",\"%S\",\"%S\",\"%S\",\"%S\"", (char*)start_date, (char*)end_date, (char*)wallet_id, (char*)base_currency, (char*)quote_currency); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_GET_PORTFOLIO_HISTORY, jpayload, NULL, &res, NULL);                                              \
    _free(jpayload);                                                                                                                                                        \
    if (r) return r;                                                                                                                                                        \
  }
#define FN_WALLET_SERVICE_GET_PORTFOLIO_HISTORY "wallet_service_get_portfolio_history"

/**
 * method to query tasks. Tasks are a side-effect of other actions performed in the system that change state such as creating a wallet.
 *
 * Returns:
 *   - d_token_t* : (ws_task) a list of tasks
 */
#define TRY_CALL_WALLET_SERVICE_LIST_TASKS(ctx, res)                                                          \
  {                                                                                                           \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_LIST_TASKS, "", NULL, &res, NULL); \
    if (r) return r;                                                                                          \
  }
#define FN_WALLET_SERVICE_LIST_TASKS "wallet_service_list_tasks"

/**
 * get a wallet tx
 *
 *
 * Parameters:
 *
 *   - char* wallet_id : (string) the id of the wallet whose transaction was created
 *   - char* id        : (string) the id of the transaction
 * Returns:
 *   - d_token_t* : (ws_transaction) the transaction
 */
#define TRY_CALL_WALLET_SERVICE_GET_WALLET_TRANSACTION(ctx, res, wallet_id, id)                                                 \
  {                                                                                                                             \
    char*      jpayload = sprintx("\"%S\",\"%S\"", (char*)wallet_id, (char*)id);                                                \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_GET_WALLET_TRANSACTION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                            \
    if (r) return r;                                                                                                            \
  }
#define FN_WALLET_SERVICE_GET_WALLET_TRANSACTION "wallet_service_get_wallet_transaction"

/**
 * sends a transaction
 *
 *
 * Parameters:
 *
 *   - char*      wallet_id : (string) the id of the wallet will be used
 *   - d_token_t* tx        : (tx_data) the transaction data
 * Returns:
 *   - d_token_t* : (ws_send_transaction_result) the transaction that was created
 */
#define TRY_CALL_WALLET_SERVICE_SEND_TRANSACTION(ctx, res, wallet_id, tx)                                                 \
  {                                                                                                                       \
    char*      jpayload = sprintx("\"%S\",%j", (char*)wallet_id, (d_token_t*) tx);                                        \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_SEND_TRANSACTION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                      \
    if (r) return r;                                                                                                      \
  }
#define FN_WALLET_SERVICE_SEND_TRANSACTION "wallet_service_send_transaction"

/**
 * submit exchange provision transaction. for WALLET_EXEC consent, the payload should be signed already by caller.
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx : (ws_create_exchange_provision_transaction) the transaction data
 * Returns:
 *   - d_token_t* : (ws_exchange_provision_transaction) the submit transaction result
 */
#define TRY_CALL_WALLET_SERVICE_SUBMIT_TRANSACTION(ctx, res, tx)                                                            \
  {                                                                                                                         \
    char*      jpayload = sprintx("%j", (d_token_t*) tx);                                                                   \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_SUBMIT_TRANSACTION, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                        \
    if (r) return r;                                                                                                        \
  }
#define FN_WALLET_SERVICE_SUBMIT_TRANSACTION "wallet_service_submit_transaction"

/**
 * sends a transaction and waits until it is mined
 *
 *
 * Parameters:
 *
 *   - char*      wallet_id : (string) the id of the wallet will be used
 *   - d_token_t* tx        : (tx_data) the transaction data
 * Returns:
 *   - d_token_t* : (ws_transaction) the transaction
 */
#define TRY_CALL_WALLET_SERVICE_SEND_TRANSACTION_AND_WAIT(ctx, res, wallet_id, tx)                                                 \
  {                                                                                                                                \
    char*      jpayload = sprintx("\"%S\",%j", (char*)wallet_id, (d_token_t*) tx);                                                 \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_SEND_TRANSACTION_AND_WAIT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                               \
    if (r) return r;                                                                                                               \
  }
#define FN_WALLET_SERVICE_SEND_TRANSACTION_AND_WAIT "wallet_service_send_transaction_and_wait"

/**
 * create a multisig wallet via wallet service. The creation is asynchronous and result contains the embedded task associated with the operation. To query further the creation result, use `get_task`. The chain used as a reference is the one whose sdk is configured (that works as a implicit parameter for the wallet creation).
 *
 *
 * Parameters:
 *
 *   - char*      chainId   : (string) the chain for that wallet
 *   - uint32_t   threshold : (uint32) the threshold of the multisig
 *   - d_token_t* owners    : (string) the owners (accounts) associated with the wallet
 * Returns:
 *   - d_token_t* : (ws_wallet) The result of wallet creation including wallet address
 */
#define TRY_CALL_WALLET_SERVICE_CREATE_WALLET(ctx, res, chainId, threshold, owners)                                    \
  {                                                                                                                    \
    char*      jpayload = sprintx("\"%S\",\"%u\",%j", (char*)chainId, (uint32_t)threshold, (d_token_t*) owners);       \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_CREATE_WALLET, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                   \
    if (r) return r;                                                                                                   \
  }
#define FN_WALLET_SERVICE_CREATE_WALLET "wallet_service_create_wallet"

/**
 * create a multisig wallet via wallet service and wait until the operation is done.
 *
 *
 * Parameters:
 *
 *   - char*      chainId   : (string) the chain for that wallet
 *   - uint32_t   threshold : (uint32) the threshold of the multisig
 *   - d_token_t* owners    : (string) the owners (accounts) associated with the wallet
 * Returns:
 *   - d_token_t* : (ws_wallet) The resulting wallet. Result should be the same of the `getWallet` query
 */
#define TRY_CALL_WALLET_SERVICE_CREATE_WALLET_AND_WAIT(ctx, res, chainId, threshold, owners)                                    \
  {                                                                                                                             \
    char*      jpayload = sprintx("\"%S\",\"%u\",%j", (char*)chainId, (uint32_t)threshold, (d_token_t*) owners);                \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_CREATE_WALLET_AND_WAIT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                            \
    if (r) return r;                                                                                                            \
  }
#define FN_WALLET_SERVICE_CREATE_WALLET_AND_WAIT "wallet_service_create_wallet_and_wait"

/**
 * List all the wallets for the user.
 *
 * Returns:
 *   - d_token_t* : (ws_wallet) The users wallets.
 */
#define TRY_CALL_WALLET_SERVICE_LIST_WALLETS(ctx, res)                                                          \
  {                                                                                                             \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_LIST_WALLETS, "", NULL, &res, NULL); \
    if (r) return r;                                                                                            \
  }
#define FN_WALLET_SERVICE_LIST_WALLETS "wallet_service_list_wallets"

/**
 * Get the wallet for the user by Id.
 *
 *
 * Parameters:
 *
 *   - char* id : (string) the id of the wallet
 * Returns:
 *   - d_token_t* : (ws_wallet) The users wallet.
 */
#define TRY_CALL_WALLET_SERVICE_GET_WALLET(ctx, res, id)                                                            \
  {                                                                                                                 \
    char*      jpayload = sprintx("\"%S\"", (char*)id);                                                             \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_GET_WALLET, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                \
    if (r) return r;                                                                                                \
  }
#define FN_WALLET_SERVICE_GET_WALLET "wallet_service_get_wallet"

/**
 * List the supported chains.
 *
 * Returns:
 *   - d_token_t* : (ws_chain_info) The chains.
 */
#define TRY_CALL_WALLET_SERVICE_LIST_CHAINS(ctx, res)                                                          \
  {                                                                                                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_LIST_CHAINS, "", NULL, &res, NULL); \
    if (r) return r;                                                                                           \
  }
#define FN_WALLET_SERVICE_LIST_CHAINS "wallet_service_list_chains"

/**
 * Create an account
 *
 *
 * Parameters:
 *
 *   - char*    name    : (string) The name of the account
 *   - char*    iban    : (string) The IBAN code of the account
 *   - uint64_t balance : (uint64) The balance of the account (???)
 * Returns:
 *   - d_token_t* : (ws_account) Account information.
 */
#define TRY_CALL_WALLET_SERVICE_CREATE_ACCOUNT(ctx, res, name, iban, balance)                                           \
  {                                                                                                                     \
    char*      jpayload = sprintx("\"%S\",\"%S\",\"%U\"", (char*)name, (char*)iban, (uint64_t)balance);                 \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_CREATE_ACCOUNT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                    \
    if (r) return r;                                                                                                    \
  }
#define FN_WALLET_SERVICE_CREATE_ACCOUNT "wallet_service_create_account"

/**
 * Get accounts that user has
 *
 * Returns:
 *   - d_token_t* : (ws_account) List of the account information
 */
#define TRY_CALL_WALLET_SERVICE_GET_ACCOUNTS(ctx, res)                                                          \
  {                                                                                                             \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_GET_ACCOUNTS, "", NULL, &res, NULL); \
    if (r) return r;                                                                                            \
  }
#define FN_WALLET_SERVICE_GET_ACCOUNTS "wallet_service_get_accounts"

/**
 * Get the balance of given account ID
 *
 *
 * Parameters:
 *
 *   - char* id : (string) The account id
 * Returns:
 *   - char* : (string) Balance of the account
 */
#define TRY_CALL_WALLET_SERVICE_GET_ACCOUNT_BALANCE(ctx, _res, id)                                                           \
  {                                                                                                                          \
    d_token_t* res;                                                                                                          \
    char*      jpayload = sprintx("\"%S\"", (char*)id);                                                                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_GET_ACCOUNT_BALANCE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                         \
    if (r) return r;                                                                                                         \
    _res = d_string(res);                                                                                                    \
  }
#define FN_WALLET_SERVICE_GET_ACCOUNT_BALANCE "wallet_service_get_account_balance"

/**
 * Delete an accouont
 *
 *
 * Parameters:
 *
 *   - char* id : (string) The account id to delete
 * Returns:
 *   - d_token_t* : (undefined) the result
 */
#define TRY_CALL_WALLET_SERVICE_DELETE_ACCOUNT(ctx, res, id)                                                            \
  {                                                                                                                     \
    char*      jpayload = sprintx("\"%S\"", (char*)id);                                                                 \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_DELETE_ACCOUNT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                    \
    if (r) return r;                                                                                                    \
  }
#define FN_WALLET_SERVICE_DELETE_ACCOUNT "wallet_service_delete_account"

/**
 * Get account detail
 *
 *
 * Parameters:
 *
 *   - char* id : (string) The account id
 * Returns:
 *   - d_token_t* : (ws_account) The account detail
 */
#define TRY_CALL_WALLET_SERVICE_GET_ACCOUNT(ctx, res, id)                                                            \
  {                                                                                                                  \
    char*      jpayload = sprintx("\"%S\"", (char*)id);                                                              \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_GET_ACCOUNT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                 \
    if (r) return r;                                                                                                 \
  }
#define FN_WALLET_SERVICE_GET_ACCOUNT "wallet_service_get_account"

/**
 * Modify account name and IBAN of the account ID
 *
 *
 * Parameters:
 *
 *   - char* id   : (string) The id of the account
 *   - char* name : (string) The name of the account
 *   - char* iban : (string) The IBAN code of the account
 * Returns:
 *   - d_token_t* : (ws_account) The modified account detail
 */
#define TRY_CALL_WALLET_SERVICE_MODIFY_ACCOUNT(ctx, res, id, name, iban)                                                \
  {                                                                                                                     \
    char*      jpayload = sprintx("\"%S\",\"%S\",\"%S\"", (char*)id, (char*)name, (char*)iban);                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_MODIFY_ACCOUNT, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                    \
    if (r) return r;                                                                                                    \
  }
#define FN_WALLET_SERVICE_MODIFY_ACCOUNT "wallet_service_modify_account"

/**
 * Get list of the token
 *
 * Returns:
 *   - d_token_t* : (ws_token) List of the token
 */
#define TRY_CALL_WALLET_SERVICE_GET_TOKEN(ctx, res)                                                          \
  {                                                                                                          \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_SERVICE_GET_TOKEN, "", NULL, &res, NULL); \
    if (r) return r;                                                                                         \
  }
#define FN_WALLET_SERVICE_GET_TOKEN "wallet_service_get_token"

/**
 * adds a wallet-configuration to the settings. This can be done by calling this function or by using `configure({wallets:[...]})`. If the wallet already exists, the properties are merged.
 *
 *
 * Parameters:
 *
 *   - d_token_t* wallet : (ms_def) the config of the wallet
 * Returns:
 *   - d_token_t* : (ms_def) the wallet - definition after merge.
 */
#define TRY_CALL_WALLET_ADD(ctx, res, wallet)                                                        \
  {                                                                                                  \
    char*      jpayload = sprintx("%j", (d_token_t*) wallet);                                        \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_ADD, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                 \
    if (r) return r;                                                                                 \
  }
#define FN_WALLET_ADD "wallet_add"

/**
 * parse a ethereum-url based on EIP 681 (https://eips.ethereum.org/EIPS/eip-681)
 *
 *
 * Parameters:
 *
 *   - char* url : (string) the url with the tx-params
 * Returns:
 *   - d_token_t* : (tx_input) the result
 */
#define TRY_CALL_WALLET_PARSE_TX_URL(ctx, res, url)                                                           \
  {                                                                                                           \
    char*      jpayload = sprintx("\"%S\"", (char*)url);                                                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_WALLET_PARSE_TX_URL, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_WALLET_PARSE_TX_URL "wallet_parse_tx_url"

/**
 * creates a new Layer 2 Wallet.
 *
 * This wallet is created directly in Layer 2 (Zksync), but features a full multisig wallet. It also holds the option to deploy contracts to layer 1 if needed. This is the case if,
 *
 * - the zksync operator stops its service or censors your tx
 * - if the approver service stop running or rejects valid requests
 *
 * In this case a deployment to Layer 1 may cost some fees, but ensures full access to all funds.
 *
 * In order to use this the SDK needs to have those properties in `zk_wallet` configured:
 *
 * - `zksync.musig_urls` - the url of the approving service
 * - `zksync.sync_key` - the seed for the signing key
 * - `zksync.create_proof_method` - which creates the proof needed. This should be `zk_wallet_create_signatures` for most cases.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t    threshold : (int) the minimal number of signatures needed for the multisig to approve a transaction. It must be at least one and less or equal to the number of owners.
 *   - d_token_t* owners    : (string) array of owners.
 *                            Each owner is described by either the address ( with role as approver) or `ROLE:ADDRESS`.
 *                            Role can be either
 *                            - `R` - Recovery : this owner can challenge other owners in order to recover, but not approve or initiate a transaction
 *                            - `A` - Approver: a signature from this owner counts towards the threshhold, but this role alone can not initiate a transaction.
 *                            - `I` - Initiator: is allowed to initiate a transaction.
 *
 *                            you can combine multiple Role like `IA:0xab35d7cb3...`
 *
 * Returns:
 *   - d_token_t* : ([object Object]) a collection of relevant data you may need for the new wallet
 */
#define TRY_CALL_ZK_WALLET_CREATE(ctx, res, threshold, owners)                                             \
  {                                                                                                        \
    char*      jpayload = sprintx("\"%B\",%j", (bytes_t) threshold, (d_token_t*) owners);                  \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZK_WALLET_CREATE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                       \
    if (r) return r;                                                                                       \
  }
#define FN_ZK_WALLET_CREATE "zk_wallet_create"

/**
 * reads the current configuration from the cosigner. This function will only be used internally and is not available as direct comand in the client.
 *
 * Returns:
 *   - d_token_t* : ([object Object]) the current config of the signer.
 */
#define TRY_CALL_ZK_WALLET_GET_CONFIG(ctx, res)                                                          \
  {                                                                                                      \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZK_WALLET_GET_CONFIG, "", NULL, &res, NULL); \
    if (r) return r;                                                                                     \
  }
#define FN_ZK_WALLET_GET_CONFIG "zk_wallet_get_config"

/**
 * updates a wallet configuration, which allows the owner to add or replace keys. Each change needs to be signed by enough owners to reach the threshold.
 * Those signatures are signing the hashed wallet-configuration, which is build:
 *
 * - `address` account_address (20 bytes)
 * - `bytes32` public key signer (32 bytes)
 * - `uint32` threshold ( bigendian )
 * - for each owner:
 *   - `uint8` role
 *   - `address` owner address
 *
 *
 *
 * Parameters:
 *
 *   - d_token_t* wallet : (zk_wallet) the new wallet-config.
 *   - d_token_t* proof  : (bytes) the proof or the signatures of the current owners reaching the threshold. The datastructure depends on the proof_method, but per default is the result of `zk_wallet_create_signatures`. The signatures need to sign the new structure.
 * Returns:
 *   - bool : (bool) the success confirmation or a error is thrown.
 */
#define TRY_CALL_ZK_WALLET_SET(ctx, _res, wallet, proof)                                                \
  {                                                                                                     \
    d_token_t* res;                                                                                     \
    char*      jpayload = sprintx("%j,%j", (d_token_t*) wallet, (d_token_t*) proof);                    \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZK_WALLET_SET, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                    \
    if (r) return r;                                                                                    \
    _res = d_int(res);                                                                                  \
  }
#define FN_ZK_WALLET_SET "zk_wallet_set"

/**
 * updates the local wallet configuration.
 *
 *
 *
 * Parameters:
 *
 *   - d_token_t* wallet : (zk_wallet) the wallet-config.
 * Returns:
 *   - bool : (bool) the success confirmation or a error is thrown.
 */
#define TRY_CALL_ZK_WALLET_CONFIGURE(ctx, _res, wallet)                                                       \
  {                                                                                                           \
    d_token_t* res;                                                                                           \
    char*      jpayload = sprintx("%j", (d_token_t*) wallet);                                                 \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZK_WALLET_CONFIGURE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
    _res = d_int(res);                                                                                        \
  }
#define FN_ZK_WALLET_CONFIGURE "zk_wallet_configure"

/**
 * signs a message by as many owners as possible to reach the threshold.
 *
 *
 * Parameters:
 *
 *   - bytes_t  message : (bytes) the message to sign
 *   - uint8_t* account : (address) the account of the wallet
 * Returns:
 *   - d_token_t* : (bytes) a array of signatures from the owner
 */
#define TRY_CALL_ZK_WALLET_CREATE_SIGNATURES(ctx, res, message, account)                                              \
  {                                                                                                                   \
    char*      jpayload = sprintx("\"%B\",\"%B\"", (bytes_t) message, bytes(account, 20));                            \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZK_WALLET_CREATE_SIGNATURES, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                  \
    if (r) return r;                                                                                                  \
  }
#define FN_ZK_WALLET_CREATE_SIGNATURES "zk_wallet_create_signatures"

/**
 * verifies signatures and checks if the threshold is reached.
 *
 *
 * Parameters:
 *
 *   - bytes_t    message    : (bytes) the message to sign
 *   - uint8_t*   account    : (address) the account of the wallet
 *   - bytes_t    signer     : (bytes32) the public key of the signer
 *   - d_token_t* signatures : (bytes) the signatures of the owner
 * Returns:
 *   - bool : (bool) returns true or an error if the signatures are not enough or invalid.
 */
#define TRY_CALL_ZK_WALLET_VERIFY_SIGNATURES(ctx, _res, message, account, signer, signatures)                                                   \
  {                                                                                                                                             \
    d_token_t* res;                                                                                                                             \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\",%j", (bytes_t) message, bytes(account, 20), (bytes_t) signer, (d_token_t*) signatures); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZK_WALLET_VERIFY_SIGNATURES, jpayload, NULL, &res, NULL);                           \
    _free(jpayload);                                                                                                                            \
    if (r) return r;                                                                                                                            \
    _res = d_int(res);                                                                                                                          \
  }
#define FN_ZK_WALLET_VERIFY_SIGNATURES "zk_wallet_verify_signatures"

/**
 * returns the contract address
 *
 * Returns:
 *   - d_token_t* : ([object Object]) fetches the contract addresses from the zksync server. This request also caches them and will return the results from cahe if available.
 */
#define TRY_CALL_ZKSYNC_CONTRACT_ADDRESS(ctx, res)                                                          \
  {                                                                                                         \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_CONTRACT_ADDRESS, "", NULL, &res, NULL); \
    if (r) return r;                                                                                        \
  }
#define FN_ZKSYNC_CONTRACT_ADDRESS "zksync_contract_address"

/**
 * returns the list of all available tokens
 *
 * Returns:
 *   - d_token_t* : ([object Object]) a array of tokens-definitions. This request also caches them and will return the results from cahe if available.
 */
#define TRY_CALL_ZKSYNC_TOKENS(ctx, res)                                                          \
  {                                                                                               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_TOKENS, "", NULL, &res, NULL); \
    if (r) return r;                                                                              \
  }
#define FN_ZKSYNC_TOKENS "zksync_tokens"

/**
 * returns account_info from the server
 *
 *
 * Parameters:
 *
 *   - uint8_t* address : (address) the account-address. if not specified, the client will try to use its own address based on the signer config.
 * Returns:
 *   - d_token_t* : ([object Object]) the current state of the requested account.
 */
#define TRY_CALL_ZKSYNC_ACCOUNT_INFO(ctx, res, address)                                                       \
  {                                                                                                           \
    char*      jpayload = sprintx("\"%B\"", bytes(address, 20));                                              \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_ACCOUNT_INFO, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                          \
    if (r) return r;                                                                                          \
  }
#define FN_ZKSYNC_ACCOUNT_INFO "zksync_account_info"

/**
 * returns the state or receipt of the the zksync-tx
 *
 *
 * Parameters:
 *
 *   - bytes_t tx : (bytes32) the txHash of the send tx
 * Returns:
 *   - d_token_t* : ([object Object]) the current state of the requested tx.
 */
#define TRY_CALL_ZKSYNC_TX_INFO(ctx, res, tx)                                                            \
  {                                                                                                      \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) tx);                                               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_TX_INFO, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
  }
#define FN_ZKSYNC_TX_INFO "zksync_tx_info"

/**
 * returns the full input data of a transaction. In order to use this, the `rest_api` needs to be set in the config.
 *
 *
 * Parameters:
 *
 *   - bytes_t tx : (bytes32) the txHash of the send tx
 * Returns:
 *   - d_token_t* : ([object Object]) the data and state of the requested tx.
 */
#define TRY_CALL_ZKSYNC_TX_DATA(ctx, res, tx)                                                            \
  {                                                                                                      \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) tx);                                               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_TX_DATA, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
  }
#define FN_ZKSYNC_TX_DATA "zksync_tx_data"

/**
 * returns the history of transaction for a given account.
 *
 *
 * Parameters:
 *
 *   - uint8_t* account   : (address) the address of the account
 *   - char*    ref_start : (string) the reference or start. this could be a tx_id prefixed with `<` or `>`for newer or older than the specified  tx or `pending` returning all pending tx.
 *   - bytes_t  limit     : (int) the max number of entries to return
 * Returns:
 *   - d_token_t* : (zk_history) the data and state of the requested tx.
 */
#define TRY_CALL_ZKSYNC_ACCOUNT_HISTORY(ctx, res, account, ref_start, limit)                                      \
  {                                                                                                               \
    char*      jpayload = sprintx("\"%B\",\"%S\",\"%B\"", bytes(account, 20), (char*)ref_start, (bytes_t) limit); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_ACCOUNT_HISTORY, jpayload, NULL, &res, NULL);  \
    _free(jpayload);                                                                                              \
    if (r) return r;                                                                                              \
  }
#define FN_ZKSYNC_ACCOUNT_HISTORY "zksync_account_history"

/**
 * sets the signerkey based on the current pk or as configured in the config.
 * You can specify the key by either
 * - setting a signer ( the sync key will be derrived through a signature )
 * - setting the seed directly ( `sync_key` in the config)
 * - setting the `musig_pub_keys` to generate the pubKeyHash based on them
 * - setting the `create2` options and the sync-key will generate the account based on the pubKeyHash
 *
 *
 * we support 3 different signer types (`signer_type` in the `zksync` config) :
 *
 * 1. `pk` - Simple Private Key
 *     If a signer is set (for example by setting the pk), incubed will derrive the sync-key through a signature and use it
 * 2. `contract` - Contract Signature
 *     In this case a preAuth-tx will be send on L1 using the signer. If this contract is a mutisig, you should make sure, you have set the account explicitly in the config and also activate the multisig-plugin, so the transaction will be send through the multisig.
 * 3. `create2` - Create2 based Contract
 *
 *
 *
 * Parameters:
 *
 *   - char* token : (string) the token to pay the gas (either the symbol or the address)
 * Returns:
 *   - uint8_t* : (address) the pubKeyHash, if it was executed successfully
 */
#define TRY_CALL_ZKSYNC_SET_KEY(ctx, _res, token)                                                        \
  {                                                                                                      \
    d_token_t* res;                                                                                      \
    char*      jpayload = sprintx("\"%S\"", (char*)token);                                               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_SET_KEY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                     \
    if (r) return r;                                                                                     \
    _res = d_bytes(res).data;                                                                            \
  }
#define FN_ZKSYNC_SET_KEY "zksync_set_key"

/**
 * returns the current PubKeyHash based on the configuration set.
 *
 *
 * Parameters:
 *
 *   - bytes_t pubKey : (bytes32) the packed public key to hash ( if given the hash is build based on the given hash, otherwise the hash is based on the config)
 * Returns:
 *   - uint8_t* : (address) the pubKeyHash
 */
#define TRY_CALL_ZKSYNC_PUBKEYHASH(ctx, _res, pubKey)                                                       \
  {                                                                                                         \
    d_token_t* res;                                                                                         \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) pubKey);                                              \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_PUBKEYHASH, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                        \
    if (r) return r;                                                                                        \
    _res = d_bytes(res).data;                                                                               \
  }
#define FN_ZKSYNC_PUBKEYHASH "zksync_pubkeyhash"

/**
 * returns the current packed PubKey based on the config set.
 *
 * If the config contains public keys for musig-signatures, the keys will be aggregated, otherwise the pubkey will be derrived from the signing key set.
 *
 *
 * Returns:
 *   - bytes_t : (bytes32) the pubKey
 */
#define TRY_CALL_ZKSYNC_PUBKEY(ctx, _res)                                                         \
  {                                                                                               \
    d_token_t* res;                                                                               \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_PUBKEY, "", NULL, &res, NULL); \
    if (r) return r;                                                                              \
    _res = d_bytes(res);                                                                          \
  }
#define FN_ZKSYNC_PUBKEY "zksync_pubkey"

/**
 * returns the address of the account used.
 *
 * Returns:
 *   - uint8_t* : (address) the account used.
 */
#define TRY_CALL_ZKSYNC_ACCOUNT_ADDRESS(ctx, _res)                                                         \
  {                                                                                                        \
    d_token_t* res;                                                                                        \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_ACCOUNT_ADDRESS, "", NULL, &res, NULL); \
    if (r) return r;                                                                                       \
    _res = d_bytes(res).data;                                                                              \
  }
#define FN_ZKSYNC_ACCOUNT_ADDRESS "zksync_account_address"

/**
 * returns the schnorr musig signature based on the current config.
 *
 * This also supports signing with multiple keys. In this case the configuration needs to sets the urls of the other keys, so the client can then excange all data needed in order to create the combined signature.
 * when exchanging the data with other keys, all known data will be send using `zk_sign` as method, but instead of the raw message a object with those data will be passed.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t message : (bytes) the message to sign
 * Returns:
 *   - bytes_t : (bytes96) The return value are 96 bytes of signature:
 *         - `[0...32]` packed public key
 *         - `[32..64]` r-value
 *         - `[64..96]` s-value
 */
#define TRY_CALL_ZKSYNC_SIGN(ctx, _res, message)                                                      \
  {                                                                                                   \
    d_token_t* res;                                                                                   \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) message);                                       \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_SIGN, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                  \
    if (r) return r;                                                                                  \
    _res = d_bytes(res);                                                                              \
  }
#define FN_ZKSYNC_SIGN "zksync_sign"

/**
 * returns 0 or 1 depending on the successfull verification of the signature.
 *
 * if the `musig_pubkeys` are set it will also verify against the given public keys list.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t message   : (bytes) the message which was supposed to be signed
 *   - bytes_t signature : (bytes96) the signature (96 bytes)
 * Returns:
 *   - bytes_t : (int) 1 if the signature(which contains the pubkey as the first 32bytes) matches the message.
 */
#define TRY_CALL_ZKSYNC_VERIFY(ctx, _res, message, signature)                                           \
  {                                                                                                     \
    d_token_t* res;                                                                                     \
    char*      jpayload = sprintx("\"%B\",\"%B\"", (bytes_t) message, (bytes_t) signature);             \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_VERIFY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                    \
    if (r) return r;                                                                                    \
    _res = d_bytes(res);                                                                                \
  }
#define FN_ZKSYNC_VERIFY "zksync_verify"

/**
 * returns the state or receipt of the the PriorityOperation
 *
 *
 * Parameters:
 *
 *   - uint64_t opId : (uint64) the opId of a layer-operstion (like depositing)
 * Returns:
 *   - d_token_t* : ([object Object]) state of the PriorityOperation
 */
#define TRY_CALL_ZKSYNC_ETHOP_INFO(ctx, res, opId)                                                          \
  {                                                                                                         \
    char*      jpayload = sprintx("\"%U\"", (uint64_t)opId);                                                \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_ETHOP_INFO, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                        \
    if (r) return r;                                                                                        \
  }
#define FN_ZKSYNC_ETHOP_INFO "zksync_ethop_info"

/**
 * returns current token-price
 *
 *
 * Parameters:
 *
 *   - char* token : (string) Symbol or address of the token
 * Returns:
 *   - d_token_t* : (double) the token price
 */
#define TRY_CALL_ZKSYNC_GET_TOKEN_PRICE(ctx, res, token)                                                         \
  {                                                                                                              \
    char*      jpayload = sprintx("\"%S\"", (char*)token);                                                       \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_GET_TOKEN_PRICE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                             \
    if (r) return r;                                                                                             \
  }
#define FN_ZKSYNC_GET_TOKEN_PRICE "zksync_get_token_price"

/**
 * calculates the fees for a transaction.
 *
 *
 * Parameters:
 *
 *   - char*    txType  : (string) The Type of the transaction "Withdraw" or "Transfer"
 *   - uint8_t* address : (address) the address of the receipient
 *   - char*    token   : (string) the symbol or address of the token to pay
 * Returns:
 *   - d_token_t* : ([object Object]) the fees split up into single values
 */
#define TRY_CALL_ZKSYNC_GET_TX_FEE(ctx, res, txType, address, token)                                        \
  {                                                                                                         \
    char*      jpayload = sprintx("\"%S\",\"%B\",\"%S\"", (char*)txType, bytes(address, 20), (char*)token); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_GET_TX_FEE, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                        \
    if (r) return r;                                                                                        \
  }
#define FN_ZKSYNC_GET_TX_FEE "zksync_get_tx_fee"

/**
 * returns private key used for signing zksync-transactions
 *
 * Returns:
 *   - bytes_t : (bytes) the raw private key configured based on the signers seed
 */
#define TRY_CALL_ZKSYNC_SYNC_KEY(ctx, _res)                                                         \
  {                                                                                                 \
    d_token_t* res;                                                                                 \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_SYNC_KEY, "", NULL, &res, NULL); \
    if (r) return r;                                                                                \
    _res = d_bytes(res);                                                                            \
  }
#define FN_ZKSYNC_SYNC_KEY "zksync_sync_key"

/**
 * sends a deposit-transaction and returns the opId, which can be used to tradck progress.
 *
 *
 * Parameters:
 *
 *   - bytes_t  amount                       : (uint256) the value to deposit in wei (or smallest token unit)
 *   - char*    token                        : (string) the token as symbol or address
 *   - bool     approveDepositAmountForERC20 : (bool) if true and in case of an erc20-token, the client will send a approve transaction first, otherwise it is expected to be already approved.
 *   - uint8_t* account                      : (address) address of the account to send the tx from. if not specified, the first available signer will be used.
 * Returns:
 *   - d_token_t* : ([object Object]) the receipt and the receipopId. You can use `zksync_ethop_info` to follow the state-changes.
 */
#define TRY_CALL_ZKSYNC_DEPOSIT(ctx, res, amount, token, approveDepositAmountForERC20, account)                                                       \
  {                                                                                                                                                   \
    char*      jpayload = sprintx("\"%B\",\"%S\",%i,\"%B\"", (bytes_t) amount, (char*)token, (int) approveDepositAmountForERC20, bytes(account, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_DEPOSIT, jpayload, NULL, &res, NULL);                                              \
    _free(jpayload);                                                                                                                                  \
    if (r) return r;                                                                                                                                  \
  }
#define FN_ZKSYNC_DEPOSIT "zksync_deposit"

/**
 * sends a zksync-transaction and returns data including the transactionHash.
 *
 *
 * Parameters:
 *
 *   - uint8_t* to      : (address) the receipient of the tokens
 *   - bytes_t  amount  : (uint256) the value to transfer in wei (or smallest token unit)
 *   - char*    token   : (string) the token as symbol or address
 *   - uint8_t* account : (address) address of the account to send the tx from. if not specified, the first available signer will be used.
 * Returns:
 *   - d_token_t* : (zk_receipt) the transactionReceipt. use `zksync_tx_info` to check the progress.
 */
#define TRY_CALL_ZKSYNC_TRANSFER(ctx, res, to, amount, token, account)                                                               \
  {                                                                                                                                  \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%S\",\"%B\"", bytes(to, 20), (bytes_t) amount, (char*)token, bytes(account, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_TRANSFER, jpayload, NULL, &res, NULL);                            \
    _free(jpayload);                                                                                                                 \
    if (r) return r;                                                                                                                 \
  }
#define FN_ZKSYNC_TRANSFER "zksync_transfer"

/**
 * withdraws the amount to the given `ethAddress` for the given token.
 *
 *
 * Parameters:
 *
 *   - uint8_t* ethAddress : (address) the receipient of the tokens in L1
 *   - bytes_t  amount     : (uint256) the value to transfer in wei (or smallest token unit)
 *   - char*    token      : (string) the token as symbol or address
 *   - uint8_t* account    : (address) address of the account to send the tx from. if not specified, the first available signer will be used.
 * Returns:
 *   - d_token_t* : (zk_receipt) the transactionReceipt. use `zksync_tx_info` to check the progress.
 */
#define TRY_CALL_ZKSYNC_WITHDRAW(ctx, res, ethAddress, amount, token, account)                                                               \
  {                                                                                                                                          \
    char*      jpayload = sprintx("\"%B\",\"%B\",\"%S\",\"%B\"", bytes(ethAddress, 20), (bytes_t) amount, (char*)token, bytes(account, 20)); \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_WITHDRAW, jpayload, NULL, &res, NULL);                                    \
    _free(jpayload);                                                                                                                         \
    if (r) return r;                                                                                                                         \
  }
#define FN_ZKSYNC_WITHDRAW "zksync_withdraw"

/**
 * withdraws all tokens for the specified token as a onchain-transaction. This is useful in case the zksync-server is offline or tries to be malicious.
 *
 *
 * Parameters:
 *
 *   - char* token : (string) the token as symbol or address
 * Returns:
 *   - d_token_t* : (eth_transactionReceipt) the transactionReceipt
 */
#define TRY_CALL_ZKSYNC_EMERGENCY_WITHDRAW(ctx, res, token)                                                         \
  {                                                                                                                 \
    char*      jpayload = sprintx("\"%S\"", (char*)token);                                                          \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_EMERGENCY_WITHDRAW, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                                \
    if (r) return r;                                                                                                \
  }
#define FN_ZKSYNC_EMERGENCY_WITHDRAW "zksync_emergency_withdraw"

/**
 * calculate the public key based on multiple public keys signing together using schnorr musig signatures.
 *
 *
 * Parameters:
 *
 *   - bytes_t pubkeys : (bytes) concatinated packed publickeys of the signers. the length of the bytes must be `num_keys * 32`
 * Returns:
 *   - bytes_t : (bytes32) the compact public Key
 */
#define TRY_CALL_ZKSYNC_AGGREGATE_PUBKEY(ctx, _res, pubkeys)                                                      \
  {                                                                                                               \
    d_token_t* res;                                                                                               \
    char*      jpayload = sprintx("\"%B\"", (bytes_t) pubkeys);                                                   \
    in3_ret_t  r        = req_send_sub_request(ctx->req, FN_ZKSYNC_AGGREGATE_PUBKEY, jpayload, NULL, &res, NULL); \
    _free(jpayload);                                                                                              \
    if (r) return r;                                                                                              \
    _res = d_bytes(res);                                                                                          \
  }
#define FN_ZKSYNC_AGGREGATE_PUBKEY "zksync_aggregate_pubkey"

#endif