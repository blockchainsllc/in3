/*******************************************************************************
 * This file is part of the Incubed project.
 * Sources: https://github.com/slockit/in3-c
 *
 * Copyright (C) 2018-2022 slock.it GmbH, Blockchains LLC
 *
 *
 * COMMERCIAL LICENSE USAGE
 *
 * Licensees holding a valid commercial license may use this file in accordance
 * with the commercial license agreement provided with the Software or, alternatively,
 * in accordance with the terms contained in a written agreement between you and
 * slock.it GmbH/Blockchains LLC. For licensing terms and conditions or further
 * information please contact slock.it at in3@slock.it.
 *
 * Alternatively, this file may be used under the AGPL license as follows:
 *
 * AGPL LICENSE USAGE
 *
 * This program is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * [Permissions of this strong copyleft license are conditioned on making available
 * complete source code of licensed works and modifications, which include larger
 * works using a licensed work, under the same license. Copyright and license notices
 * must be preserved. Contributors provide an express grant of patent rights.]
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see <https://www.gnu.org/licenses/>.
 *******************************************************************************/

// ::: This is a autogenerated file. Do not edit it manually! :::

#include "../../core/client/request_internal.h"

// list of availbale rpc-functions
#ifndef __RPC_BTC_H
#define __RPC_BTC_H

/**
 * Returns data of block header for given block hash. The returned level of details depends on the argument verbosity.
 *
 *
 * Parameters:
 *
 *   - bytes_t hash      : (bytes32) The block hash
 *   - bool    verbosity : (bool) 0 or false for the hex-encoded data, 1 or true for a json object
 * Returns:
 *   - d_token_t* : (btcblockheader) the blockheader.
 *         - verbose `0` or `false`: a hex string with 80 bytes representing the blockheader
 *         - verbose `1` or `true`: an object representing the blockheader.
 */
static inline in3_ret_t rpc_call_getblockheader(in3_rpc_handle_ctx_t* ctx, d_token_t** res, bytes_t hash, bool verbosity) {
  char*      jpayload = sprintx("\"%B\",%i", (bytes_t) hash, (int) verbosity);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "getblockheader", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_GETBLOCKHEADER "getblockheader"

/**
 * Returns data of block for given block hash. The returned level of details depends on the argument verbosity.
 *
 *
 * Parameters:
 *
 *   - bytes_t hash      : (bytes32) The block hash
 *   - bytes_t verbosity : (int) 0 or false for hex-encoded data, 1 or true for a json object, and 2 for json object **with** transaction data
 * Returns:
 *   - d_token_t* : (btcblockWithTx) the block.
 *         - verbose `0` or `false`: a hex string with 80 bytes representing the blockheader
 *         - verbose `1` or `true`: an object representing the blockheader.
 */
static inline in3_ret_t rpc_call_getblock(in3_rpc_handle_ctx_t* ctx, d_token_t** res, bytes_t hash, bytes_t verbosity) {
  char*      jpayload = sprintx("\"%B\",\"%B\"", (bytes_t) hash, (bytes_t) verbosity);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "getblock", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_GETBLOCK "getblock"

/**
 * Returns the raw transaction data. The returned level of details depends on the argumentÂ verbosity.
 *
 *
 * Parameters:
 *
 *   - bytes_t txid      : (bytes32) The transaction id
 *   - bytes_t verbosity : (int) 0 or false for the hex-encoded data for `txid`, 1 or true for a json object with information about `txid`
 *   - bytes_t blockhash : (bytes32) The block in which to look for the transaction
 * Returns:
 *   - d_token_t* : (btctransaction) - verbose `0` or `false`: a string that is serialized, hex-encoded data for `txid`
 *         - verbose `1` or `false`: an object representing the transaction.
 */
static inline in3_ret_t rpc_call_getrawtransaction(in3_rpc_handle_ctx_t* ctx, d_token_t** res, bytes_t txid, bytes_t verbosity, bytes_t blockhash) {
  char*      jpayload = sprintx("\"%B\",\"%B\",\"%B\"", (bytes_t) txid, (bytes_t) verbosity, (bytes_t) blockhash);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "getrawtransaction", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_GETRAWTRANSACTION "getrawtransaction"

/**
 * Returns a btc address given some inut data and an address type
 *
 *
 * Parameters:
 *
 *   - char* data : (string) This is the data used by the api to generate and address.
 *                  The nature of this parameted changes according to the type of address to generate.
 *                  For "p2pkh" this field should contain a 65-byte btc public key or a 33-byte btc compressed pub key.
 *                  For "p2sh", this field should contain a raw btc locking script.
 *
 *   - char* type : (string) The address type to generate.
 *
 * Returns:
 *   - char* : (string) The encoded btc address
 */
static inline in3_ret_t rpc_call_createaddress(in3_rpc_handle_ctx_t* ctx, char** _res, char* data, char* type) {
  d_token_t* res = NULL;
  char*      jpayload = sprintx("\"%S\",\"%S\"", (char*)data, (char*)type);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "createaddress", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_string(res);
  return r;
}
#define FN_CREATEADDRESS "createaddress"

/**
 * Returns a list of addresses or public keys extracted from the outputs of a transaction
 *
 *
 * Parameters:
 *
 *   - char*   tx        : (string) Either the transaction id or the raw btc transaction.
 *                         When this field is 64 characters long (32 bytes), it is treated as transaction id the function will fetch the raw transaction
 *                         from the configured chain with a subrequest.
 *                         When it is bigger than 64 characters (32 bytes), this field is treated as a raw transaction, and no subrequest will be made.
 *
 *   - bytes_t blockhash : (bytes32) The block in which to look for the transaction
 * Returns:
 *   - d_token_t* : (btc_output_address) The addresses and/or public keys extracted fom transaction outputs
 */
static inline in3_ret_t rpc_call_getaddresses(in3_rpc_handle_ctx_t* ctx, d_token_t** res, char* tx, bytes_t blockhash) {
  char*      jpayload = sprintx("\"%S\",\"%B\"", (char*)tx, (bytes_t) blockhash);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "getaddresses", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_GETADDRESSES "getaddresses"

/**
 * Returns the number of blocks in the longest blockchain.
 *
 * Returns:
 *   - uint64_t : (uint64) the current blockheight
 */
static inline in3_ret_t rpc_call_getblockcount(in3_rpc_handle_ctx_t* ctx, uint64_t* _res) {
  d_token_t* res = NULL;
  in3_ret_t  r        = req_send_sub_request(ctx->req, "getblockcount", "", NULL, &res, NULL);
  if (!r) *_res = d_long(res);
  return r;
}
#define FN_GETBLOCKCOUNT "getblockcount"

/**
 * Returns hash of block in best-block-chain at height provided.
 *
 *
 * Parameters:
 *
 *   - uint64_t height : (uint64) The block number
 * Returns:
 *   - bytes_t : (bytes32) the current blockheight
 */
static inline in3_ret_t rpc_call_getblockhash(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, uint64_t height) {
  d_token_t* res = NULL;
  char*      jpayload = sprintx("\"%U\"", (uint64_t)height);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "getblockhash", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_GETBLOCKHASH "getblockhash"

/**
 * Returns the proof-of-work difficulty as a multiple of the minimum difficulty.
 *
 * Returns:
 *   - d_token_t* : (double) - `blocknumber` is a certain number: the difficulty of this block
 *         - `blocknumber` is `latest`, `earliest`, `pending` or empty: the difficulty of the latest block (`actual latest block` minus `in3.finality`)
 */
static inline in3_ret_t rpc_call_getdifficulty(in3_rpc_handle_ctx_t* ctx, d_token_t** res) {
  in3_ret_t  r        = req_send_sub_request(ctx->req, "getdifficulty", "", NULL, res, NULL);
  return r;
}
#define FN_GETDIFFICULTY "getdifficulty"

/**
 * Whenever the client is not able to trust the changes of the target (which is the case if a block can't be found in the verified target cache *and* the value of the target changed more than the client's limit `max_diff`) he will call this method. It will return additional proof data to verify the changes of the target on the side of the client. This is not a standard Bitcoin rpc-method like the other ones, but more like an internal method.
 *
 *
 * Parameters:
 *
 *   - uint64_t target_dap   : (uint64) the number of the difficulty adjustment period (dap) we are looking for
 *   - uint64_t verified_dap : (uint64) the number of the closest already verified dap
 *   - bytes_t  max_diff     : (int) the maximum target difference between 2 verified daps
 *   - bytes_t  max_dap      : (int) the maximum amount of daps between 2 verified daps
 *   - bytes_t  limit        : (int) the maximum amount of daps to return (`0` = no limit) - this is important for embedded devices since returning all daps might be too much for limited memory
 * Returns:
 *   - d_token_t* : ([object Object]) A path of daps from the `verified_dap` to the `target_dap` which fulfils the conditions of `max_diff`, `max_dap` and `limit`. Each dap of the path is a `dap`-object with corresponding proof data.
 */
static inline in3_ret_t rpc_call_btc_proofTarget(in3_rpc_handle_ctx_t* ctx, d_token_t** res, uint64_t target_dap, uint64_t verified_dap, bytes_t max_diff, bytes_t max_dap, bytes_t limit) {
  char*      jpayload = sprintx("\"%U\",\"%U\",\"%B\",\"%B\",\"%B\"", (uint64_t)target_dap, (uint64_t)verified_dap, (bytes_t) max_diff, (bytes_t) max_dap, (bytes_t) limit);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "btc_proofTarget", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_BTC_PROOFTARGET "btc_proofTarget"

/**
 * Returns the hash of the best (tip) block in the longest blockchain.
 *
 * Returns:
 *   - bytes_t : (bytes32) the hash of the best block
 */
static inline in3_ret_t rpc_call_getbestblockhash(in3_rpc_handle_ctx_t* ctx, bytes_t* _res) {
  d_token_t* res = NULL;
  in3_ret_t  r        = req_send_sub_request(ctx->req, "getbestblockhash", "", NULL, &res, NULL);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_GETBESTBLOCKHASH "getbestblockhash"

/**
 * signs and sends a transaction to a btc node
 *
 *
 *
 * Parameters:
 *
 *   - uint8_t*   from    : (address) 20-byte btc address to which the "change" from the utxos will be sent
 *   - d_token_t* account : (btc_sign_acc) default eth account used by in3 to sign btc transactions
 *   - d_token_t* outputs : (btc_value) how much and to which adresses we want to send funds
 *   - d_token_t* utxos   : (utxo) the utxos used to provide funds for the transaction
 * Returns:
 *   - bytes_t : (bytes32) the transactionhash
 */
static inline in3_ret_t rpc_call_sendtransaction(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, uint8_t* from, d_token_t* account, d_token_t* outputs, d_token_t* utxos) {
  d_token_t* res = NULL;
  char*      jpayload = sprintx("\"%B\",%j,%j,%j", bytes(from, 20), (d_token_t*) account, (d_token_t*) outputs, (d_token_t*) utxos);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "sendtransaction", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_SENDTRANSACTION "sendtransaction"

/**
 * sends a transaction to a btc node
 *
 *
 * Parameters:
 *
 *   - char* transaction : (string) the signed raw transaction
 * Returns:
 *   - bytes_t : (bytes32) the transactionhash
 */
static inline in3_ret_t rpc_call_sendrawtransaction(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, char* transaction) {
  d_token_t* res = NULL;
  char*      jpayload = sprintx("\"%S\"", (char*)transaction);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "sendrawtransaction", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_SENDRAWTRANSACTION "sendrawtransaction"

#endif