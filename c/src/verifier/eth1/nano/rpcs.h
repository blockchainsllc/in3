/*******************************************************************************
 * This file is part of the Incubed project.
 * Sources: https://github.com/slockit/in3-c
 *
 * Copyright (C) 2018-2022 slock.it GmbH, Blockchains LLC
 *
 *
 * COMMERCIAL LICENSE USAGE
 *
 * Licensees holding a valid commercial license may use this file in accordance
 * with the commercial license agreement provided with the Software or, alternatively,
 * in accordance with the terms contained in a written agreement between you and
 * slock.it GmbH/Blockchains LLC. For licensing terms and conditions or further
 * information please contact slock.it at in3@slock.it.
 *
 * Alternatively, this file may be used under the AGPL license as follows:
 *
 * AGPL LICENSE USAGE
 *
 * This program is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
 * [Permissions of this strong copyleft license are conditioned on making available
 * complete source code of licensed works and modifications, which include larger
 * works using a licensed work, under the same license. Copyright and license notices
 * must be preserved. Contributors provide an express grant of patent rights.]
 * You should have received a copy of the GNU Affero General Public License along
 * with this program. If not, see <https://www.gnu.org/licenses/>.
 *******************************************************************************/

// ::: This is a autogenerated file. Do not edit it manually! :::
// clang-format off

#include "../../../core/client/request_internal.h"

// list of availbale rpc-functions
#ifndef __RPC_ETH_H
#define __RPC_ETH_H

/**
 * returns the current gasPrice in wei per gas
 *
 * Returns:
 *   - uint64_t : (uint64) the current gasPrice in wei per gas
 */
static inline in3_ret_t rpc_call_eth_gasPrice(in3_rpc_handle_ctx_t* ctx, uint64_t* _res) {
  d_token_t* res = NULL;
  in3_ret_t  r   = req_send_sub_request(ctx->req, "eth_gasPrice", "", NULL, &res, NULL);
  if (!r) *_res = d_long(res);
  return r;
}
#define FN_ETH_GASPRICE "eth_gasPrice"

/**
 * base fee per gas and transaction effective priority fee per gas history for the requested block range if available.
 * The range between headBlock-4 and headBlock is guaranteed to be available while retrieving data from the pending block and older history are optional to support.
 * For pre-EIP-1559 blocks the gas prices are returned as rewards and zeroes are returned for the base fee per gas
 *
 *
 *
 * Parameters:
 *
 *   - uint64_t   blockCount        : (uint64) Number of blocks in the requested range. Between 1 and 1024 blocks can be requested in a single query. Less than requested may be returned if not all blocks are available.
 *   - uint64_t   newestBlock       : (uint64) the Highest blockNumber or one of `latest`, `earliest`or `pending`
 *   - d_token_t* rewardPercentiles : (double) A monotonically increasing list of percentile values to sample from each block's effective priority fees per gas in ascending order, weighted by gas used.
 * Returns:
 *   - d_token_t* : ([object Object]) Fee history for the returned block range. This can be a subsection of the requested range if not all blocks are available.
 */
static inline in3_ret_t rpc_call_eth_feeHistory(in3_rpc_handle_ctx_t* ctx, d_token_t** res, uint64_t blockCount, uint64_t newestBlock, d_token_t* rewardPercentiles) {
  char*     jpayload = sprintx("\"%U\",\"%U\",%j", (uint64_t) blockCount, (uint64_t) newestBlock, (d_token_t*) rewardPercentiles);
  in3_ret_t r        = req_send_sub_request(ctx->req, "eth_feeHistory", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_ETH_FEEHISTORY "eth_feeHistory"

/**
 * returns the number of the most recent block.
 *
 * See [eth_blockNumber](https://eth.wiki/json-rpc/API#eth_blockNumber) for spec.
 *
 * No proof returned, since there is none, but the client should verify the result by comparing it to the current blocks returned from others.
 * With the `blockTime` from the chainspec, including a tolerance, the current blocknumber may be checked if in the proposed range.
 *
 *
 * Returns:
 *   - uint64_t : (uint64) the highest known blocknumber
 */
static inline in3_ret_t rpc_call_eth_blockNumber(in3_rpc_handle_ctx_t* ctx, uint64_t* _res) {
  d_token_t* res = NULL;
  in3_ret_t  r   = req_send_sub_request(ctx->req, "eth_blockNumber", "", NULL, &res, NULL);
  if (!r) *_res = d_long(res);
  return r;
}
#define FN_ETH_BLOCKNUMBER "eth_blockNumber"

/**
 * returns information about a block by block number.
 *
 * See [eth_getBlockByNumber](https://eth.wiki/json-rpc/API#eth_getBlockByNumber) for spec.
 *
 *
 *
 * Parameters:
 *
 *   - uint64_t blockNumber : (uint64) the blockNumber or one of `latest`, `earliest`or `pending`
 *   - bool     fullTx      : (bool) if true the full transactions are contained in the result.
 * Returns:
 *   - d_token_t* : (eth_blockdata) the blockdata, or in case the block with that number does not exist, `null` will be returned.
 */
static inline in3_ret_t rpc_call_eth_getBlockByNumber(in3_rpc_handle_ctx_t* ctx, d_token_t** res, uint64_t blockNumber, bool fullTx) {
  char*     jpayload = sprintx("\"%U\",%i", (uint64_t) blockNumber, (int) fullTx);
  in3_ret_t r        = req_send_sub_request(ctx->req, "eth_getBlockByNumber", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_ETH_GETBLOCKBYNUMBER "eth_getBlockByNumber"

/**
 * Returns information about a block by hash.
 *
 * See [eth_getBlockByHash](https://eth.wiki/json-rpc/API#eth_getBlockByHash) for spec.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t blockHash : (bytes32) the blockHash of the block
 *   - bool    fullTx    : (bool) if true the full transactions are contained in the result.
 * Returns:
 *   - d_token_t* : (eth_blockdata) the blockdata, or in case the block with that number does not exist, `null` will be returned.
 */
static inline in3_ret_t rpc_call_eth_getBlockByHash(in3_rpc_handle_ctx_t* ctx, d_token_t** res, bytes_t blockHash, bool fullTx) {
  char*     jpayload = sprintx("\"%B\",%i", (bytes_t) blockHash, (int) fullTx);
  in3_ret_t r        = req_send_sub_request(ctx->req, "eth_getBlockByHash", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_ETH_GETBLOCKBYHASH "eth_getBlockByHash"

/**
 * returns the number of transactions. For Spec, see [eth_getBlockTransactionCountByHash](https://eth.wiki/json-rpc/API#eth_getBlockTransactionCountByHash).
 *
 *
 * Parameters:
 *
 *   - bytes_t blockHash : (bytes32) the blockHash of the block
 * Returns:
 *   - bytes_t : (int) the number of transactions in the block
 */
static inline in3_ret_t rpc_call_eth_getBlockTransactionCountByHash(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, bytes_t blockHash) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\"", (bytes_t) blockHash);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "eth_getBlockTransactionCountByHash", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_ETH_GETBLOCKTRANSACTIONCOUNTBYHASH "eth_getBlockTransactionCountByHash"

/**
 * returns the number of transactions. For Spec, see [eth_getBlockTransactionCountByNumber](https://eth.wiki/json-rpc/API#eth_getBlockTransactionCountByNumber).
 *
 *
 * Parameters:
 *
 *   - uint64_t blockNumber : (uint64) the blockNumber of the block
 * Returns:
 *   - bytes_t : (int) the number of transactions in the block
 */
static inline in3_ret_t rpc_call_eth_getBlockTransactionCountByNumber(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, uint64_t blockNumber) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%U\"", (uint64_t) blockNumber);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "eth_getBlockTransactionCountByNumber", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_ETH_GETBLOCKTRANSACTIONCOUNTBYNUMBER "eth_getBlockTransactionCountByNumber"

/**
 * returns the number of uncles. For Spec, see [eth_getUncleCountByBlockHash](https://eth.wiki/json-rpc/API#eth_getUncleCountByBlockHash).
 *
 *
 * Parameters:
 *
 *   - bytes_t blockHash : (bytes32) the blockHash of the block
 * Returns:
 *   - bytes_t : (int) the number of uncles
 */
static inline in3_ret_t rpc_call_eth_getUncleCountByBlockHash(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, bytes_t blockHash) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\"", (bytes_t) blockHash);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "eth_getUncleCountByBlockHash", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_ETH_GETUNCLECOUNTBYBLOCKHASH "eth_getUncleCountByBlockHash"

/**
 * returns the number of uncles. For Spec, see [eth_getUncleCountByBlockNumber](https://eth.wiki/json-rpc/API#eth_getUncleCountByBlockNumber).
 *
 *
 * Parameters:
 *
 *   - uint64_t blockNumber : (uint64) the blockNumber of the block
 * Returns:
 *   - bytes_t : (int) the number of uncles
 */
static inline in3_ret_t rpc_call_eth_getUncleCountByBlockNumber(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, uint64_t blockNumber) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%U\"", (uint64_t) blockNumber);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "eth_getUncleCountByBlockNumber", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_ETH_GETUNCLECOUNTBYBLOCKNUMBER "eth_getUncleCountByBlockNumber"

/**
 * returns the transaction data.
 *
 * See JSON-RPC-Spec for [eth_getTransactionByBlockHashAndIndex](https://eth.wiki/json-rpc/API#eth_getTransactionByBlockHashAndIndex) for more details.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t blockHash : (bytes32) the blockhash containing the transaction.
 *   - bytes_t index     : (int) the transactionIndex
 * Returns:
 *   - d_token_t* : (eth_transactiondata) the transactiondata or `null` if it does not exist
 */
static inline in3_ret_t rpc_call_eth_getTransactionByBlockHashAndIndex(in3_rpc_handle_ctx_t* ctx, d_token_t** res, bytes_t blockHash, bytes_t index) {
  char*     jpayload = sprintx("\"%B\",\"%B\"", (bytes_t) blockHash, (bytes_t) index);
  in3_ret_t r        = req_send_sub_request(ctx->req, "eth_getTransactionByBlockHashAndIndex", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_ETH_GETTRANSACTIONBYBLOCKHASHANDINDEX "eth_getTransactionByBlockHashAndIndex"

/**
 * returns the transaction data.
 *
 * See JSON-RPC-Spec for [eth_getTransactionByBlockNumberAndIndex](https://eth.wiki/json-rpc/API#eth_getTransactionByBlockNumberAndIndex) for more details.
 *
 *
 *
 * Parameters:
 *
 *   - uint64_t blockNumber : (uint64) the block number containing the transaction.
 *   - bytes_t  index       : (int) the transactionIndex
 * Returns:
 *   - d_token_t* : (eth_transactiondata) the transactiondata or `null` if it does not exist
 */
static inline in3_ret_t rpc_call_eth_getTransactionByBlockNumberAndIndex(in3_rpc_handle_ctx_t* ctx, d_token_t** res, uint64_t blockNumber, bytes_t index) {
  char*     jpayload = sprintx("\"%U\",\"%B\"", (uint64_t) blockNumber, (bytes_t) index);
  in3_ret_t r        = req_send_sub_request(ctx->req, "eth_getTransactionByBlockNumberAndIndex", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_ETH_GETTRANSACTIONBYBLOCKNUMBERANDINDEX "eth_getTransactionByBlockNumberAndIndex"

/**
 * returns the transaction data.
 *
 * See JSON-RPC-Spec for [eth_getTransactionByHash](https://eth.wiki/json-rpc/API#eth_getTransactionByHash) for more details.
 *
 *
 *
 * Parameters:
 *
 *   - bytes_t txHash : (bytes32) the transactionHash of the transaction.
 * Returns:
 *   - d_token_t* : (eth_transactiondata) the transactiondata or `null` if it does not exist
 */
static inline in3_ret_t rpc_call_eth_getTransactionByHash(in3_rpc_handle_ctx_t* ctx, d_token_t** res, bytes_t txHash) {
  char*     jpayload = sprintx("\"%B\"", (bytes_t) txHash);
  in3_ret_t r        = req_send_sub_request(ctx->req, "eth_getTransactionByHash", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_ETH_GETTRANSACTIONBYHASH "eth_getTransactionByHash"

/**
 * searches for events matching the given criteria. See [eth_getLogs](https://eth.wiki/json-rpc/API#eth_getLogs) for the spec.
 *
 *
 * Parameters:
 *
 *   - d_token_t* filter : ([object Object]) The filter criteria for the events.
 * Returns:
 *   - d_token_t* : (ethlog) array with all found event matching the specified filter
 */
static inline in3_ret_t rpc_call_eth_getLogs(in3_rpc_handle_ctx_t* ctx, d_token_t** res, d_token_t* filter) {
  char*     jpayload = sprintx("%j", (d_token_t*) filter);
  in3_ret_t r        = req_send_sub_request(ctx->req, "eth_getLogs", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_ETH_GETLOGS "eth_getLogs"

/**
 * gets the balance of an account for a given block
 *
 *
 * Parameters:
 *
 *   - uint8_t* account : (address) address of the account
 *   - uint64_t block   : (uint64) the blockNumber or `latest`
 * Returns:
 *   - bytes_t : (uint256) the balance
 */
static inline in3_ret_t rpc_call_eth_getBalance(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, uint8_t* account, uint64_t block) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\",\"%U\"", bytes(account, 20), (uint64_t) block);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "eth_getBalance", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_ETH_GETBALANCE "eth_getBalance"

/**
 * gets the nonce or number of transaction sent from this account at a given block
 *
 *
 * Parameters:
 *
 *   - uint8_t* account : (address) address of the account
 *   - uint64_t block   : (uint64) the blockNumber or  `latest`
 * Returns:
 *   - uint64_t : (uint64) the nonce
 */
static inline in3_ret_t rpc_call_eth_getTransactionCount(in3_rpc_handle_ctx_t* ctx, uint64_t* _res, uint8_t* account, uint64_t block) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\",\"%U\"", bytes(account, 20), (uint64_t) block);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "eth_getTransactionCount", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_long(res);
  return r;
}
#define FN_ETH_GETTRANSACTIONCOUNT "eth_getTransactionCount"

/**
 * gets the code of a given contract
 *
 *
 * Parameters:
 *
 *   - uint8_t* account : (address) address of the account
 *   - uint64_t block   : (uint64) the blockNumber or `latest`
 * Returns:
 *   - bytes_t : (bytes) the code as hex
 */
static inline in3_ret_t rpc_call_eth_getCode(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, uint8_t* account, uint64_t block) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\",\"%U\"", bytes(account, 20), (uint64_t) block);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "eth_getCode", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_ETH_GETCODE "eth_getCode"

/**
 * gets the storage value of a given key
 *
 *
 * Parameters:
 *
 *   - uint8_t* account : (address) address of the account
 *   - bytes_t  key     : (bytes32) key to look for
 *   - uint64_t block   : (uint64) the blockNumber or`latest`
 * Returns:
 *   - bytes_t : (bytes) the value of the storage slot.
 */
static inline in3_ret_t rpc_call_eth_getStorageAt(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, uint8_t* account, bytes_t key, uint64_t block) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\",\"%B\",\"%U\"", bytes(account, 20), (bytes_t) key, (uint64_t) block);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "eth_getStorageAt", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_ETH_GETSTORAGEAT "eth_getStorageAt"

/**
 * signs and sends a Transaction
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx : (eth_transaction) the transactiondata to send
 * Returns:
 *   - bytes_t : (bytes) the transactionHash
 */
static inline in3_ret_t rpc_call_eth_sendTransaction(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, d_token_t* tx) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("%j", (d_token_t*) tx);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "eth_sendTransaction", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_ETH_SENDTRANSACTION "eth_sendTransaction"

/**
 * signs and sends a Transaction, but then waits until the transaction receipt can be verified. Depending on the finality of the nodes, this may take a while, since only final blocks will be signed by the nodes.
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx : (eth_transaction) the transactiondata to send
 * Returns:
 *   - d_token_t* : (eth_transactionReceipt) the transactionReceipt
 */
static inline in3_ret_t rpc_call_eth_sendTransactionAndWait(in3_rpc_handle_ctx_t* ctx, d_token_t** res, d_token_t* tx) {
  char*     jpayload = sprintx("%j", (d_token_t*) tx);
  in3_ret_t r        = req_send_sub_request(ctx->req, "eth_sendTransactionAndWait", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_ETH_SENDTRANSACTIONANDWAIT "eth_sendTransactionAndWait"

/**
 * sends or broadcasts a prviously signed raw transaction. See [eth_sendRawTransaction](https://eth.wiki/json-rpc/API#eth_sendRawTransaction)
 *
 *
 * Parameters:
 *
 *   - bytes_t tx : (bytes) the raw signed transactiondata to send
 * Returns:
 *   - bytes_t : (bytes32) the transactionhash
 */
static inline in3_ret_t rpc_call_eth_sendRawTransaction(in3_rpc_handle_ctx_t* ctx, bytes_t* _res, bytes_t tx) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("\"%B\"", (bytes_t) tx);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "eth_sendRawTransaction", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_bytes(res);
  return r;
}
#define FN_ETH_SENDRAWTRANSACTION "eth_sendRawTransaction"

/**
 * calculates the gas needed to execute a transaction. for spec see [eth_estimateGas](https://eth.wiki/json-rpc/API#eth_estimateGas)
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx    : (eth_transaction) the tx-object, which is the same as specified in [eth_sendTransaction](https://eth.wiki/json-rpc/API#eth_sendTransaction).
 *   - uint64_t   block : (uint64) the blockNumber or  `latest`
 * Returns:
 *   - uint64_t : (uint64) the amount of gass needed.
 */
static inline in3_ret_t rpc_call_eth_estimateGas(in3_rpc_handle_ctx_t* ctx, uint64_t* _res, d_token_t* tx, uint64_t block) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("%j,\"%U\"", (d_token_t*) tx, (uint64_t) block);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "eth_estimateGas", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_long(res);
  return r;
}
#define FN_ETH_ESTIMATEGAS "eth_estimateGas"

/**
 * calls a function of a contract (or simply executes the evm opcodes) and returns the result. for spec see [eth_call](https://eth.wiki/json-rpc/API#eth_call)
 *
 *
 * Parameters:
 *
 *   - d_token_t* tx    : (eth_transaction) the tx-object, which is the same as specified in [eth_sendTransaction](https://eth.wiki/json-rpc/API#eth_sendTransaction).
 *   - uint64_t   block : (uint64) the blockNumber or  `latest`
 * Returns:
 *   - char* : (string) the abi-encoded result of the function.
 */
static inline in3_ret_t rpc_call_eth_call(in3_rpc_handle_ctx_t* ctx, char** _res, d_token_t* tx, uint64_t block) {
  d_token_t* res      = NULL;
  char*      jpayload = sprintx("%j,\"%U\"", (d_token_t*) tx, (uint64_t) block);
  in3_ret_t  r        = req_send_sub_request(ctx->req, "eth_call", jpayload, NULL, &res, NULL);
  _free(jpayload);
  if (!r) *_res = d_string(res);
  return r;
}
#define FN_ETH_CALL "eth_call"

/**
 * The Receipt of a Transaction. For Details, see [eth_getTransactionReceipt](https://eth.wiki/json-rpc/API#eth_gettransactionreceipt).
 *
 *
 * Parameters:
 *
 *   - bytes_t txHash : (bytes32) the transactionHash
 * Returns:
 *   - d_token_t* : (eth_transactionReceipt) the TransactionReceipt or `null`  if it does not exist.
 */
static inline in3_ret_t rpc_call_eth_getTransactionReceipt(in3_rpc_handle_ctx_t* ctx, d_token_t** res, bytes_t txHash) {
  char*     jpayload = sprintx("\"%B\"", (bytes_t) txHash);
  in3_ret_t r        = req_send_sub_request(ctx->req, "eth_getTransactionReceipt", jpayload, NULL, res, NULL);
  _free(jpayload);
  return r;
}
#define FN_ETH_GETTRANSACTIONRECEIPT "eth_getTransactionReceipt"

#endif